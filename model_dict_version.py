"""Standalone SAM2 model builder and predictor helpers."""

from __future__ import annotations

import importlib.abc
import importlib.util
import inspect
import sys
from typing import Dict, Any

import torch
import yaml
from hydra.utils import instantiate
from omegaconf import OmegaConf

EMBEDDED_SOURCES: Dict[str, str] = {
    'efficient_track_anything': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom hydra import initialize_config_module\nfrom hydra.core.global_hydra import GlobalHydra\n\nif not GlobalHydra.instance().is_initialized():\n    initialize_config_module("efficient_track_anything", version_base="1.2")\n',
    'efficient_track_anything.modeling': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'efficient_track_anything.modeling.efficienttam_utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport copy\nfrom typing import Tuple, Union\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom efficient_track_anything.utils.misc import mask_to_box\n\n\ndef select_closest_cond_frames(frame_idx, cond_frame_outputs, max_cond_frame_num):\n    """\n    Select up to `max_cond_frame_num` conditioning frames from `cond_frame_outputs`\n    that are temporally closest to the current frame at `frame_idx`. Here, we take\n    - a) the closest conditioning frame before `frame_idx` (if any);\n    - b) the closest conditioning frame after `frame_idx` (if any);\n    - c) any other temporally closest conditioning frames until reaching a total\n         of `max_cond_frame_num` conditioning frames.\n\n    Outputs:\n    - selected_outputs: selected items (keys & values) from `cond_frame_outputs`.\n    - unselected_outputs: items (keys & values) not selected in `cond_frame_outputs`.\n    """\n    if max_cond_frame_num == -1 or len(cond_frame_outputs) <= max_cond_frame_num:\n        selected_outputs = cond_frame_outputs\n        unselected_outputs = {}\n    else:\n        assert max_cond_frame_num >= 2, "we should allow using 2+ conditioning frames"\n        selected_outputs = {}\n\n        # the closest conditioning frame before `frame_idx` (if any)\n        idx_before = max((t for t in cond_frame_outputs if t < frame_idx), default=None)\n        if idx_before is not None:\n            selected_outputs[idx_before] = cond_frame_outputs[idx_before]\n\n        # the closest conditioning frame after `frame_idx` (if any)\n        idx_after = min((t for t in cond_frame_outputs if t >= frame_idx), default=None)\n        if idx_after is not None:\n            selected_outputs[idx_after] = cond_frame_outputs[idx_after]\n\n        # add other temporally closest conditioning frames until reaching a total\n        # of `max_cond_frame_num` conditioning frames.\n        num_remain = max_cond_frame_num - len(selected_outputs)\n        inds_remain = sorted(\n            (t for t in cond_frame_outputs if t not in selected_outputs),\n            key=lambda x: abs(x - frame_idx),\n        )[:num_remain]\n        selected_outputs.update((t, cond_frame_outputs[t]) for t in inds_remain)\n        unselected_outputs = {\n            t: v for t, v in cond_frame_outputs.items() if t not in selected_outputs\n        }\n\n    return selected_outputs, unselected_outputs\n\n\ndef get_1d_sine_pe(pos_inds, dim, temperature=10000):\n    """\n    Get 1D sine positional embedding as in the original Transformer paper.\n    """\n    pe_dim = dim // 2\n    dim_t = torch.arange(pe_dim, dtype=torch.float32, device=pos_inds.device)\n    dim_t = temperature ** (2 * (dim_t // 2) / pe_dim)\n\n    pos_embed = pos_inds.unsqueeze(-1) / dim_t\n    pos_embed = torch.cat([pos_embed.sin(), pos_embed.cos()], dim=-1)\n    return pos_embed\n\n\ndef get_activation_fn(activation):\n    """Return an activation function given a string"""\n    if activation == "relu":\n        return F.relu\n    if activation == "gelu":\n        return F.gelu\n    if activation == "glu":\n        return F.glu\n    raise RuntimeError(f"activation should be relu/gelu, not {activation}.")\n\n\ndef get_clones(module, N):\n    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])\n\n\nclass DropPath(nn.Module):\n    # adapted from https://github.com/huggingface/pytorch-image-models/blob/main/timm/layers/drop.py\n    def __init__(self, drop_prob=0.0, scale_by_keep=True):\n        super(DropPath, self).__init__()\n        self.drop_prob = drop_prob\n        self.scale_by_keep = scale_by_keep\n\n    def forward(self, x):\n        if self.drop_prob == 0.0 or not self.training:\n            return x\n        keep_prob = 1 - self.drop_prob\n        shape = (x.shape[0],) + (1,) * (x.ndim - 1)\n        random_tensor = x.new_empty(shape).bernoulli_(keep_prob)\n        if keep_prob > 0.0 and self.scale_by_keep:\n            random_tensor.div_(keep_prob)\n        return x * random_tensor\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        activation: nn.Module = nn.ReLU,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n        self.act = activation()\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = self.act(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x\n\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n\n\ndef sample_box_points(\n    masks: torch.Tensor,\n    noise: float = 0.1,  # SAM default\n    noise_bound: int = 20,  # SAM default\n    top_left_label: int = 2,\n    bottom_right_label: int = 3,\n) -> Tuple[np.array, np.array]:\n    """\n    Sample a noised version of the top left and bottom right corners of a given `bbox`\n\n    Inputs:\n    - masks: [B, 1, H,W] boxes, dtype=torch.Tensor\n    - noise: noise as a fraction of box width and height, dtype=float\n    - noise_bound: maximum amount of noise (in pure pixesl), dtype=int\n\n    Returns:\n    - box_coords: [B, num_pt, 2], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.float\n    - box_labels: [B, num_pt], label 2 is reserverd for top left and 3 for bottom right corners, dtype=torch.int32\n    """\n    device = masks.device\n    box_coords = mask_to_box(masks)\n    B, _, H, W = masks.shape\n    box_labels = torch.tensor(\n        [top_left_label, bottom_right_label], dtype=torch.int, device=device\n    ).repeat(B)\n    if noise > 0.0:\n        if not isinstance(noise_bound, torch.Tensor):\n            noise_bound = torch.tensor(noise_bound, device=device)\n        bbox_w = box_coords[..., 2] - box_coords[..., 0]\n        bbox_h = box_coords[..., 3] - box_coords[..., 1]\n        max_dx = torch.min(bbox_w * noise, noise_bound)\n        max_dy = torch.min(bbox_h * noise, noise_bound)\n        box_noise = 2 * torch.rand(B, 1, 4, device=device) - 1\n        box_noise = box_noise * torch.stack((max_dx, max_dy, max_dx, max_dy), dim=-1)\n\n        box_coords = box_coords + box_noise\n        img_bounds = (\n            torch.tensor([W, H, W, H], device=device) - 1\n        )  # uncentered pixel coords\n        box_coords.clamp_(torch.zeros_like(img_bounds), img_bounds)  # In place clamping\n\n    box_coords = box_coords.reshape(-1, 2, 2)  # always 2 points\n    box_labels = box_labels.reshape(-1, 2)\n    return box_coords, box_labels\n\n\ndef sample_random_points_from_errors(gt_masks, pred_masks, num_pt=1):\n    """\n    Sample `num_pt` random points (along with their labels) independently from the error regions.\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - num_pt: int, number of points to sample independently for each of the B error maps\n\n    Outputs:\n    - points: [B, num_pt, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, num_pt], dtype=torch.int32, where 1 means positive clicks and 0 means\n      negative clicks\n    """\n    if pred_masks is None:  # if pred_masks is not provided, treat it as empty\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n    assert num_pt >= 0\n\n    B, _, H_im, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n    # whether the prediction completely match the ground-truth on each mask\n    all_correct = torch.all((gt_masks == pred_masks).flatten(2), dim=2)\n    all_correct = all_correct[..., None, None]\n\n    # channel 0 is FP map, while channel 1 is FN map\n    pts_noise = torch.rand(B, num_pt, H_im, W_im, 2, device=device)\n    # sample a negative new click from FP region or a positive new click\n    # from FN region, depend on where the maximum falls,\n    # and in case the predictions are all correct (no FP or FN), we just\n    # sample a negative click from the background region\n    pts_noise[..., 0] *= fp_masks | (all_correct & ~gt_masks)\n    pts_noise[..., 1] *= fn_masks\n    pts_idx = pts_noise.flatten(2).argmax(dim=2)\n    labels = (pts_idx % 2).to(torch.int32)\n    pts_idx = pts_idx // 2\n    pts_x = pts_idx % W_im\n    pts_y = pts_idx // W_im\n    points = torch.stack([pts_x, pts_y], dim=2).to(torch.float)\n    return points, labels\n\n\ndef sample_one_point_from_error_center(gt_masks, pred_masks, padding=True):\n    """\n    Sample 1 random point (along with its label) from the center of each error region,\n    that is, the point with the largest distance to the boundary of each error region.\n    This is the RITM sampling method from https://github.com/saic-vul/ritm_interactive_segmentation/blob/master/isegm/inference/clicker.py\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - padding: if True, pad with boundary of 1 px for distance transform\n\n    Outputs:\n    - points: [B, 1, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, 1], dtype=torch.int32, where 1 means positive clicks and 0 means negative clicks\n    """\n    import cv2\n\n    if pred_masks is None:\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n\n    B, _, _, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n\n    fp_masks = fp_masks.cpu().numpy()\n    fn_masks = fn_masks.cpu().numpy()\n    points = torch.zeros(B, 1, 2, dtype=torch.float)\n    labels = torch.ones(B, 1, dtype=torch.int32)\n    for b in range(B):\n        fn_mask = fn_masks[b, 0]\n        fp_mask = fp_masks[b, 0]\n        if padding:\n            fn_mask = np.pad(fn_mask, ((1, 1), (1, 1)), "constant")\n            fp_mask = np.pad(fp_mask, ((1, 1), (1, 1)), "constant")\n        # compute the distance of each point in FN/FP region to its boundary\n        fn_mask_dt = cv2.distanceTransform(fn_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        fp_mask_dt = cv2.distanceTransform(fp_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        if padding:\n            fn_mask_dt = fn_mask_dt[1:-1, 1:-1]\n            fp_mask_dt = fp_mask_dt[1:-1, 1:-1]\n\n        # take the point in FN/FP region with the largest distance to its boundary\n        fn_mask_dt_flat = fn_mask_dt.reshape(-1)\n        fp_mask_dt_flat = fp_mask_dt.reshape(-1)\n        fn_argmax = np.argmax(fn_mask_dt_flat)\n        fp_argmax = np.argmax(fp_mask_dt_flat)\n        is_positive = fn_mask_dt_flat[fn_argmax] > fp_mask_dt_flat[fp_argmax]\n        pt_idx = fn_argmax if is_positive else fp_argmax\n        points[b, 0, 0] = pt_idx % W_im  # x\n        points[b, 0, 1] = pt_idx // W_im  # y\n        labels[b, 0] = int(is_positive)\n\n    points = points.to(device)\n    labels = labels.to(device)\n    return points, labels\n\n\ndef get_next_point(gt_masks, pred_masks, method):\n    if method == "uniform":\n        return sample_random_points_from_errors(gt_masks, pred_masks)\n    elif method == "center":\n        return sample_one_point_from_error_center(gt_masks, pred_masks)\n    else:\n        raise ValueError(f"unknown sampling method {method}")\n\n\nclass LayerScale(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        init_values: Union[float, torch.Tensor] = 1e-5,\n        inplace: bool = False,\n    ) -> None:\n        super().__init__()\n        self.inplace = inplace\n        self.gamma = nn.Parameter(init_values * torch.ones(dim))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return x.mul_(self.gamma) if self.inplace else x * self.gamma\n',
    'efficient_track_anything.utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'efficient_track_anything.utils.misc': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport os\nimport warnings\nfrom threading import Thread\n\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom tqdm import tqdm\n\n\ndef get_sdpa_settings():\n    if torch.cuda.is_available():\n        old_gpu = torch.cuda.get_device_properties(0).major < 7\n        # only use Flash Attention on Ampere (8.0) or newer GPUs\n        use_flash_attn = torch.cuda.get_device_properties(0).major >= 8\n        if not use_flash_attn:\n            warnings.warn(\n                "Flash Attention is disabled as it requires a GPU with Ampere (8.0) CUDA capability.",\n                category=UserWarning,\n                stacklevel=2,\n            )\n        # keep math kernel for PyTorch versions before 2.2 (Flash Attention v2 is only\n        # available on PyTorch 2.2+, while Flash Attention v1 cannot handle all cases)\n        pytorch_version = tuple(int(v) for v in torch.__version__.split(".")[:2])\n        if pytorch_version < (2, 2):\n            warnings.warn(\n                f"You are using PyTorch {torch.__version__} without Flash Attention v2 support. "\n                "Consider upgrading to PyTorch 2.2+ for Flash Attention v2 (which could be faster).",\n                category=UserWarning,\n                stacklevel=2,\n            )\n        math_kernel_on = pytorch_version < (2, 2) or not use_flash_attn\n    else:\n        old_gpu = True\n        use_flash_attn = False\n        math_kernel_on = True\n\n    return old_gpu, use_flash_attn, math_kernel_on\n\n\ndef get_connected_components(mask):\n    """\n    Get the connected components (8-connectivity) of binary masks of shape (N, 1, H, W).\n\n    Inputs:\n    - mask: A binary mask tensor of shape (N, 1, H, W), where 1 is foreground and 0 is\n            background.\n\n    Outputs:\n    - labels: A tensor of shape (N, 1, H, W) containing the connected component labels\n              for foreground pixels and 0 for background pixels.\n    - counts: A tensor of shape (N, 1, H, W) containing the area of the connected\n              components for foreground pixels and 0 for background pixels.\n    """\n    from efficient_track_anything import _C\n\n    return _C.get_connected_componnets(mask.to(torch.uint8).contiguous())\n\n\ndef mask_to_box(masks: torch.Tensor):\n    """\n    compute bounding box given an input mask\n\n    Inputs:\n    - masks: [B, 1, H, W] masks, dtype=torch.Tensor\n\n    Returns:\n    - box_coords: [B, 1, 4], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.Tensor\n    """\n    B, _, h, w = masks.shape\n    device = masks.device\n    xs = torch.arange(w, device=device, dtype=torch.int32)\n    ys = torch.arange(h, device=device, dtype=torch.int32)\n    grid_xs, grid_ys = torch.meshgrid(xs, ys, indexing="xy")\n    grid_xs = grid_xs[None, None, ...].expand(B, 1, h, w)\n    grid_ys = grid_ys[None, None, ...].expand(B, 1, h, w)\n    min_xs, _ = torch.min(torch.where(masks, grid_xs, w).flatten(-2), dim=-1)\n    max_xs, _ = torch.max(torch.where(masks, grid_xs, -1).flatten(-2), dim=-1)\n    min_ys, _ = torch.min(torch.where(masks, grid_ys, h).flatten(-2), dim=-1)\n    max_ys, _ = torch.max(torch.where(masks, grid_ys, -1).flatten(-2), dim=-1)\n    bbox_coords = torch.stack((min_xs, min_ys, max_xs, max_ys), dim=-1)\n\n    return bbox_coords\n\n\ndef _load_img_as_tensor(img_path, image_size):\n    img_pil = Image.open(img_path)\n    img_np = np.array(img_pil.convert("RGB").resize((image_size, image_size)))\n    if img_np.dtype == np.uint8:  # np.uint8 is expected for JPEG images\n        img_np = img_np / 255.0\n    else:\n        raise RuntimeError(f"Unknown image dtype: {img_np.dtype} on {img_path}")\n    img = torch.from_numpy(img_np).permute(2, 0, 1)\n    video_width, video_height = img_pil.size  # the original video size\n    return img, video_height, video_width\n\n\nclass AsyncVideoFrameLoader:\n    """\n    A list of video frames to be load asynchronously without blocking session start.\n    """\n\n    def __init__(\n        self,\n        img_paths,\n        image_size,\n        offload_video_to_cpu,\n        img_mean,\n        img_std,\n        compute_device,\n    ):\n        self.img_paths = img_paths\n        self.image_size = image_size\n        self.offload_video_to_cpu = offload_video_to_cpu\n        self.img_mean = img_mean\n        self.img_std = img_std\n        # items in `self.images` will be loaded asynchronously\n        self.images = [None] * len(img_paths)\n        # catch and raise any exceptions in the async loading thread\n        self.exception = None\n        # video_height and video_width be filled when loading the first image\n        self.video_height = None\n        self.video_width = None\n        self.compute_device = compute_device\n\n        # load the first frame to fill video_height and video_width and also\n        # to cache it (since it\'s most likely where the user will click)\n        self.__getitem__(0)\n\n        # load the rest of frames asynchronously without blocking the session start\n        def _load_frames():\n            try:\n                for n in tqdm(range(len(self.images)), desc="frame loading (JPEG)"):\n                    self.__getitem__(n)\n            except Exception as e:\n                self.exception = e\n\n        self.thread = Thread(target=_load_frames, daemon=True)\n        self.thread.start()\n\n    def __getitem__(self, index):\n        if self.exception is not None:\n            raise RuntimeError("Failure in frame loading thread") from self.exception\n\n        img = self.images[index]\n        if img is not None:\n            return img\n\n        img, video_height, video_width = _load_img_as_tensor(\n            self.img_paths[index], self.image_size\n        )\n        self.video_height = video_height\n        self.video_width = video_width\n        # normalize by mean and std\n        img -= self.img_mean\n        img /= self.img_std\n        if not self.offload_video_to_cpu:\n            img = img.to(self.compute_device, non_blocking=True)\n        self.images[index] = img\n        return img\n\n    def __len__(self):\n        return len(self.images)\n\n\ndef load_video_frames(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    async_loading_frames=False,\n    compute_device=torch.device("cuda"),\n):\n    """\n    Load the video frames from video_path. The frames are resized to image_size as in\n    the model and are loaded to GPU if offload_video_to_cpu=False. This is used by the demo.\n    """\n    is_bytes = isinstance(video_path, bytes)\n    is_str = isinstance(video_path, str)\n    is_mp4_path = is_str and os.path.splitext(video_path)[-1] in [".mp4", ".MP4"]\n    if is_bytes or is_mp4_path:\n        return load_video_frames_from_video_file(\n            video_path=video_path,\n            image_size=image_size,\n            offload_video_to_cpu=offload_video_to_cpu,\n            img_mean=img_mean,\n            img_std=img_std,\n            compute_device=compute_device,\n        )\n    elif is_str and os.path.isdir(video_path):\n        return load_video_frames_from_jpg_images(\n            video_path=video_path,\n            image_size=image_size,\n            offload_video_to_cpu=offload_video_to_cpu,\n            img_mean=img_mean,\n            img_std=img_std,\n            async_loading_frames=async_loading_frames,\n            compute_device=compute_device,\n        )\n    else:\n        raise NotImplementedError(\n            "Only MP4 video and JPEG folder are supported at this moment"\n        )\n\n\ndef load_video_frames_from_jpg_images(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    async_loading_frames=False,\n    compute_device=torch.device("cuda"),\n):\n    """\n    Load the video frames from a directory of JPEG files ("<frame_index>.jpg" format).\n\n    The frames are resized to image_size x image_size and are loaded to GPU if\n    `offload_video_to_cpu` is `False` and to CPU if `offload_video_to_cpu` is `True`.\n\n    You can load a frame asynchronously by setting `async_loading_frames` to `True`.\n    """\n    if isinstance(video_path, str) and os.path.isdir(video_path):\n        jpg_folder = video_path\n    else:\n        raise NotImplementedError(\n            "Only JPEG frames are supported at this moment. For video files, you may use "\n            "ffmpeg (https://ffmpeg.org/) to extract frames into a folder of JPEG files, such as \\n"\n            "```\\n"\n            "ffmpeg -i <your_video>.mp4 -q:v 2 -start_number 0 <output_dir>/\'%05d.jpg\'\\n"\n            "```\\n"\n            "where `-q:v` generates high-quality JPEG frames and `-start_number 0` asks "\n            "ffmpeg to start the JPEG file from 00000.jpg."\n        )\n\n    frame_names = [\n        p\n        for p in os.listdir(jpg_folder)\n        if os.path.splitext(p)[-1] in [".jpg", ".jpeg", ".JPG", ".JPEG"]\n    ]\n    frame_names.sort(key=lambda p: int(os.path.splitext(p)[0]))\n    num_frames = len(frame_names)\n    if num_frames == 0:\n        raise RuntimeError(f"no images found in {jpg_folder}")\n    img_paths = [os.path.join(jpg_folder, frame_name) for frame_name in frame_names]\n    img_mean = torch.tensor(img_mean, dtype=torch.float32)[:, None, None]\n    img_std = torch.tensor(img_std, dtype=torch.float32)[:, None, None]\n\n    if async_loading_frames:\n        lazy_images = AsyncVideoFrameLoader(\n            img_paths,\n            image_size,\n            offload_video_to_cpu,\n            img_mean,\n            img_std,\n            compute_device,\n        )\n        return lazy_images, lazy_images.video_height, lazy_images.video_width\n\n    images = torch.zeros(num_frames, 3, image_size, image_size, dtype=torch.float32)\n    for n, img_path in enumerate(tqdm(img_paths, desc="frame loading (JPEG)")):\n        images[n], video_height, video_width = _load_img_as_tensor(img_path, image_size)\n    if not offload_video_to_cpu:\n        images = images.to(compute_device)\n        img_mean = img_mean.to(compute_device)\n        img_std = img_std.to(compute_device)\n    # normalize by mean and std\n    images -= img_mean\n    images /= img_std\n    return images, video_height, video_width\n\n\ndef load_video_frames_from_video_file(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    compute_device=torch.device("cuda"),\n):\n    """Load the video frames from a video file."""\n    import decord\n\n    img_mean = torch.tensor(img_mean, dtype=torch.float32)[:, None, None]\n    img_std = torch.tensor(img_std, dtype=torch.float32)[:, None, None]\n    # Get the original video height and width\n    decord.bridge.set_bridge("torch")\n    video_height, video_width, _ = decord.VideoReader(video_path).next().shape\n    # Iterate over all frames in the video\n    images = []\n    for frame in decord.VideoReader(video_path, width=image_size, height=image_size):\n        images.append(frame.permute(2, 0, 1))\n\n    images = torch.stack(images, dim=0).float() / 255.0\n    if not offload_video_to_cpu:\n        images = images.to(compute_device)\n        img_mean = img_mean.to(compute_device)\n        img_std = img_std.to(compute_device)\n    # normalize by mean and std\n    images -= img_mean\n    images /= img_std\n    return images, video_height, video_width\n\n\ndef fill_holes_in_mask_scores(mask, max_area):\n    """\n    A post processor to fill small holes in mask scores with area under `max_area`.\n    """\n    # Holes are those connected components in background with area <= self.max_area\n    # (background regions are those with mask scores <= 0)\n    assert max_area > 0, "max_area must be positive"\n\n    input_mask = mask\n    try:\n        labels, areas = get_connected_components(mask <= 0)\n        is_hole = (labels > 0) & (areas <= max_area)\n        # We fill holes with a small positive mask score (0.1) to change them to foreground.\n        mask = torch.where(is_hole, 0.1, mask)\n    except Exception as e:\n        # Following SAM 2, skip the post-processing step on removing small holes if the CUDA kernel fails\n        warnings.warn(\n            f"{e}\\n\\nSkipping the post-processing step due to the error above. You can "\n            "still use Efficient Track Anything and it\'s OK to ignore the error above.",\n            category=UserWarning,\n            stacklevel=2,\n        )\n        mask = input_mask\n\n    return mask\n\n\ndef concat_points(old_point_inputs, new_points, new_labels):\n    """Add new points and labels to previous point inputs (add at the end)."""\n    if old_point_inputs is None:\n        points, labels = new_points, new_labels\n    else:\n        points = torch.cat([old_point_inputs["point_coords"], new_points], dim=1)\n        labels = torch.cat([old_point_inputs["point_labels"], new_labels], dim=1)\n\n    return {"point_coords": points, "point_labels": labels}\n',
    'sam2': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom hydra import initialize_config_module\nfrom hydra.core.global_hydra import GlobalHydra\n\nif not GlobalHydra.instance().is_initialized():\n    initialize_config_module("sam2", version_base="1.2")\n',
    'sam2.build_sam': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport logging\n\nimport torch\nfrom hydra import compose\nfrom hydra.utils import instantiate\nfrom omegaconf import OmegaConf\n\nHF_MODEL_ID_TO_FILENAMES = {\n    "facebook/sam2-hiera-tiny": (\n        "configs/sam2/sam2_hiera_t.yaml",\n        "sam2_hiera_tiny.pt",\n    ),\n    "facebook/sam2-hiera-small": (\n        "configs/sam2/sam2_hiera_s.yaml",\n        "sam2_hiera_small.pt",\n    ),\n    "facebook/sam2-hiera-base-plus": (\n        "configs/sam2/sam2_hiera_b+.yaml",\n        "sam2_hiera_base_plus.pt",\n    ),\n    "facebook/sam2-hiera-large": (\n        "configs/sam2/sam2_hiera_l.yaml",\n        "sam2_hiera_large.pt",\n    ),\n    "facebook/sam2.1-hiera-tiny": (\n        "configs/sam2.1/sam2.1_hiera_t.yaml",\n        "sam2.1_hiera_tiny.pt",\n    ),\n    "facebook/sam2.1-hiera-small": (\n        "configs/sam2.1/sam2.1_hiera_s.yaml",\n        "sam2.1_hiera_small.pt",\n    ),\n    "facebook/sam2.1-hiera-base-plus": (\n        "configs/sam2.1/sam2.1_hiera_b+.yaml",\n        "sam2.1_hiera_base_plus.pt",\n    ),\n    "facebook/sam2.1-hiera-large": (\n        "configs/sam2.1/sam2.1_hiera_l.yaml",\n        "sam2.1_hiera_large.pt",\n    ),\n}\n\n\ndef get_best_available_device():\n    """\n    Get the best available device in the order: CUDA, MPS, CPU\n    Returns: device string for torch.device\n    """\n    if torch.cuda.is_available():\n        return "cuda"\n    elif hasattr(torch.backends, \'mps\') and torch.backends.mps.is_available():\n        return "mps"\n    else:\n        return "cpu"\n\n\ndef build_sam2(\n    config_file,\n    ckpt_path=None,\n    device=None,\n    mode="eval",\n    hydra_overrides_extra=[],\n    apply_postprocessing=True,\n    **kwargs,\n):\n    # Use the provided device or get the best available one\n    device = device or get_best_available_device()\n    logging.info(f"Using device: {device}")\n\n    if apply_postprocessing:\n        hydra_overrides_extra = hydra_overrides_extra.copy()\n        hydra_overrides_extra += [\n            # dynamically fall back to multi-mask if the single mask is not stable\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_via_stability=true",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_delta=0.05",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_thresh=0.98",\n        ]\n    # Read config and init model\n    cfg = compose(config_name=config_file, overrides=hydra_overrides_extra)\n    OmegaConf.resolve(cfg)\n    model = instantiate(cfg.model, _recursive_=True)\n    _load_checkpoint(model, ckpt_path)\n    model = model.to(device)\n    if mode == "eval":\n        model.eval()\n    return model\n\n\ndef build_sam2_video_predictor(\n    config_file,\n    ckpt_path=None,\n    device=None,\n    mode="eval",\n    hydra_overrides_extra=[],\n    apply_postprocessing=True,\n    **kwargs,\n):\n    # Use the provided device or get the best available one\n    device = device or get_best_available_device()\n    logging.info(f"Using device: {device}")\n\n    hydra_overrides = [\n        "++model._target_=sam2.sam2_video_predictor.SAM2VideoPredictor",\n    ]\n    if apply_postprocessing:\n        hydra_overrides_extra = hydra_overrides_extra.copy()\n        hydra_overrides_extra += [\n            # dynamically fall back to multi-mask if the single mask is not stable\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_via_stability=true",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_delta=0.05",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_thresh=0.98",\n            # the sigmoid mask logits on interacted frames with clicks in the memory encoder so that the encoded masks are exactly as what users see from clicking\n            "++model.binarize_mask_from_pts_for_mem_enc=true",\n            # fill small holes in the low-res masks up to `fill_hole_area` (before resizing them to the original video resolution)\n            "++model.fill_hole_area=8",\n        ]\n    hydra_overrides.extend(hydra_overrides_extra)\n\n    # Read config and init model\n    cfg = compose(config_name=config_file, overrides=hydra_overrides)\n    OmegaConf.resolve(cfg)\n    model = instantiate(cfg.model, _recursive_=True)\n    _load_checkpoint(model, ckpt_path)\n    model = model.to(device)\n    if mode == "eval":\n        model.eval()\n    return model\n\ndef build_sam2_video_predictor_npz(\n    config_file,\n    ckpt_path=None,\n    device=None,\n    mode="eval",\n    hydra_overrides_extra=[],\n    apply_postprocessing=True,\n    **kwargs,\n):\n    # Use the provided device or get the best available one\n    device = device or get_best_available_device()\n    logging.info(f"Using device: {device}")\n\n    hydra_overrides = [\n        "++model._target_=sam2.sam2_video_predictor_npz.SAM2VideoPredictorNPZ",\n    ]\n    if apply_postprocessing:\n        hydra_overrides_extra = hydra_overrides_extra.copy()\n        hydra_overrides_extra += [\n            # dynamically fall back to multi-mask if the single mask is not stable\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_via_stability=true",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_delta=0.05",\n            "++model.sam_mask_decoder_extra_args.dynamic_multimask_stability_thresh=0.98",\n            # the sigmoid mask logits on interacted frames with clicks in the memory encoder so that the encoded masks are exactly as what users see from clicking\n            "++model.binarize_mask_from_pts_for_mem_enc=true",\n            # fill small holes in the low-res masks up to `fill_hole_area` (before resizing them to the original video resolution)\n            "++model.fill_hole_area=8",\n        ]\n    hydra_overrides.extend(hydra_overrides_extra)\n\n    # Read config and init model\n    cfg = compose(config_name=config_file, overrides=hydra_overrides)\n    OmegaConf.resolve(cfg)\n    model = instantiate(cfg.model, _recursive_=True)\n    _load_checkpoint(model, ckpt_path)\n    model = model.to(device)\n    if mode == "eval":\n        model.eval()\n    return model\n\n\n\ndef _hf_download(model_id):\n    from huggingface_hub import hf_hub_download\n\n    config_name, checkpoint_name = HF_MODEL_ID_TO_FILENAMES[model_id]\n    ckpt_path = hf_hub_download(repo_id=model_id, filename=checkpoint_name)\n    return config_name, ckpt_path\n\n\ndef build_sam2_hf(model_id, **kwargs):\n    config_name, ckpt_path = _hf_download(model_id)\n    return build_sam2(config_file=config_name, ckpt_path=ckpt_path, **kwargs)\n\n\ndef build_sam2_video_predictor_hf(model_id, **kwargs):\n    config_name, ckpt_path = _hf_download(model_id)\n    return build_sam2_video_predictor(\n        config_file=config_name, ckpt_path=ckpt_path, **kwargs\n    )\n\n\ndef _load_checkpoint(model, ckpt_path):\n    if ckpt_path is not None:\n        sd = torch.load(ckpt_path, map_location="cpu", weights_only=True)["model"]\n        missing_keys, unexpected_keys = model.load_state_dict(sd)\n        if missing_keys:\n            logging.error(missing_keys)\n            raise RuntimeError()\n        if unexpected_keys:\n            logging.error(unexpected_keys)\n            raise RuntimeError()\n        logging.info("Loaded checkpoint sucessfully")\n',
    'sam2.modeling': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'sam2.modeling.backbones': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'sam2.modeling.backbones.hieradet': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport logging\nfrom functools import partial\nfrom typing import List, Tuple, Union\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom iopath.common.file_io import g_pathmgr\n\nfrom sam2.modeling.backbones.utils import (\n    PatchEmbed,\n    window_partition,\n    window_unpartition,\n)\n\nfrom sam2.modeling.sam2_utils import DropPath, MLP\n\n\ndef do_pool(x: torch.Tensor, pool: nn.Module, norm: nn.Module = None) -> torch.Tensor:\n    if pool is None:\n        return x\n    # (B, H, W, C) -> (B, C, H, W)\n    x = x.permute(0, 3, 1, 2)\n    x = pool(x)\n    # (B, C, H\', W\') -> (B, H\', W\', C)\n    x = x.permute(0, 2, 3, 1)\n    if norm:\n        x = norm(x)\n\n    return x\n\n\nclass MultiScaleAttention(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        dim_out: int,\n        num_heads: int,\n        q_pool: nn.Module = None,\n    ):\n        super().__init__()\n\n        self.dim = dim\n        self.dim_out = dim_out\n        self.num_heads = num_heads\n        self.q_pool = q_pool\n        self.qkv = nn.Linear(dim, dim_out * 3)\n        self.proj = nn.Linear(dim_out, dim_out)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, H, W, _ = x.shape\n        # qkv with shape (B, H * W, 3, nHead, C)\n        qkv = self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1)\n        # q, k, v with shape (B, H * W, nheads, C)\n        q, k, v = torch.unbind(qkv, 2)\n\n        # Q pooling (for downsample at stage changes)\n        if self.q_pool:\n            q = do_pool(q.reshape(B, H, W, -1), self.q_pool)\n            H, W = q.shape[1:3]  # downsampled shape\n            q = q.reshape(B, H * W, self.num_heads, -1)\n\n        # Torch\'s SDPA expects [B, nheads, H*W, C] so we transpose\n        x = F.scaled_dot_product_attention(\n            q.transpose(1, 2),\n            k.transpose(1, 2),\n            v.transpose(1, 2),\n        )\n        # Transpose back\n        x = x.transpose(1, 2)\n        x = x.reshape(B, H, W, -1)\n\n        x = self.proj(x)\n\n        return x\n\n\nclass MultiScaleBlock(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        dim_out: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        drop_path: float = 0.0,\n        norm_layer: Union[nn.Module, str] = "LayerNorm",\n        q_stride: Tuple[int, int] = None,\n        act_layer: nn.Module = nn.GELU,\n        window_size: int = 0,\n    ):\n        super().__init__()\n\n        if isinstance(norm_layer, str):\n            norm_layer = partial(getattr(nn, norm_layer), eps=1e-6)\n\n        self.dim = dim\n        self.dim_out = dim_out\n        self.norm1 = norm_layer(dim)\n\n        self.window_size = window_size\n\n        self.pool, self.q_stride = None, q_stride\n        if self.q_stride:\n            self.pool = nn.MaxPool2d(\n                kernel_size=q_stride, stride=q_stride, ceil_mode=False\n            )\n\n        self.attn = MultiScaleAttention(\n            dim,\n            dim_out,\n            num_heads=num_heads,\n            q_pool=self.pool,\n        )\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n\n        self.norm2 = norm_layer(dim_out)\n        self.mlp = MLP(\n            dim_out,\n            int(dim_out * mlp_ratio),\n            dim_out,\n            num_layers=2,\n            activation=act_layer,\n        )\n\n        if dim != dim_out:\n            self.proj = nn.Linear(dim, dim_out)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        shortcut = x  # B, H, W, C\n        x = self.norm1(x)\n\n        # Skip connection\n        if self.dim != self.dim_out:\n            shortcut = do_pool(self.proj(x), self.pool)\n\n        # Window partition\n        window_size = self.window_size\n        if window_size > 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, window_size)\n\n        # Window Attention + Q Pooling (if stage change)\n        x = self.attn(x)\n        if self.q_stride:\n            # Shapes have changed due to Q pooling\n            window_size = self.window_size // self.q_stride[0]\n            H, W = shortcut.shape[1:3]\n\n            pad_h = (window_size - H % window_size) % window_size\n            pad_w = (window_size - W % window_size) % window_size\n            pad_hw = (H + pad_h, W + pad_w)\n\n        # Reverse window partition\n        if self.window_size > 0:\n            x = window_unpartition(x, window_size, pad_hw, (H, W))\n\n        x = shortcut + self.drop_path(x)\n        # MLP\n        x = x + self.drop_path(self.mlp(self.norm2(x)))\n        return x\n\n\nclass Hiera(nn.Module):\n    """\n    Reference: https://arxiv.org/abs/2306.00989\n    """\n\n    def __init__(\n        self,\n        embed_dim: int = 96,  # initial embed dim\n        num_heads: int = 1,  # initial number of heads\n        drop_path_rate: float = 0.0,  # stochastic depth\n        q_pool: int = 3,  # number of q_pool stages\n        q_stride: Tuple[int, int] = (2, 2),  # downsample stride bet. stages\n        stages: Tuple[int, ...] = (2, 3, 16, 3),  # blocks per stage\n        dim_mul: float = 2.0,  # dim_mul factor at stage shift\n        head_mul: float = 2.0,  # head_mul factor at stage shift\n        window_pos_embed_bkg_spatial_size: Tuple[int, int] = (14, 14),\n        # window size per stage, when not using global att.\n        window_spec: Tuple[int, ...] = (\n            8,\n            4,\n            14,\n            7,\n        ),\n        # global attn in these blocks\n        global_att_blocks: Tuple[int, ...] = (\n            12,\n            16,\n            20,\n        ),\n        weights_path=None,\n        return_interm_layers=True,  # return feats from every stage\n    ):\n        super().__init__()\n\n        assert len(stages) == len(window_spec)\n        self.window_spec = window_spec\n\n        depth = sum(stages)\n        self.q_stride = q_stride\n        self.stage_ends = [sum(stages[:i]) - 1 for i in range(1, len(stages) + 1)]\n        assert 0 <= q_pool <= len(self.stage_ends[:-1])\n        self.q_pool_blocks = [x + 1 for x in self.stage_ends[:-1]][:q_pool]\n        self.return_interm_layers = return_interm_layers\n\n        self.patch_embed = PatchEmbed(\n            embed_dim=embed_dim,\n        )\n        # Which blocks have global att?\n        self.global_att_blocks = global_att_blocks\n\n        # Windowed positional embedding (https://arxiv.org/abs/2311.05613)\n        self.window_pos_embed_bkg_spatial_size = window_pos_embed_bkg_spatial_size\n        self.pos_embed = nn.Parameter(\n            torch.zeros(1, embed_dim, *self.window_pos_embed_bkg_spatial_size)\n        )\n        self.pos_embed_window = nn.Parameter(\n            torch.zeros(1, embed_dim, self.window_spec[0], self.window_spec[0])\n        )\n\n        dpr = [\n            x.item() for x in torch.linspace(0, drop_path_rate, depth)\n        ]  # stochastic depth decay rule\n\n        cur_stage = 1\n        self.blocks = nn.ModuleList()\n\n        for i in range(depth):\n            dim_out = embed_dim\n            # lags by a block, so first block of\n            # next stage uses an initial window size\n            # of previous stage and final window size of current stage\n            window_size = self.window_spec[cur_stage - 1]\n\n            if self.global_att_blocks is not None:\n                window_size = 0 if i in self.global_att_blocks else window_size\n\n            if i - 1 in self.stage_ends:\n                dim_out = int(embed_dim * dim_mul)\n                num_heads = int(num_heads * head_mul)\n                cur_stage += 1\n\n            block = MultiScaleBlock(\n                dim=embed_dim,\n                dim_out=dim_out,\n                num_heads=num_heads,\n                drop_path=dpr[i],\n                q_stride=self.q_stride if i in self.q_pool_blocks else None,\n                window_size=window_size,\n            )\n\n            embed_dim = dim_out\n            self.blocks.append(block)\n\n        self.channel_list = (\n            [self.blocks[i].dim_out for i in self.stage_ends[::-1]]\n            if return_interm_layers\n            else [self.blocks[-1].dim_out]\n        )\n\n        if weights_path is not None:\n            with g_pathmgr.open(weights_path, "rb") as f:\n                chkpt = torch.load(f, map_location="cpu")\n            logging.info("loading Hiera", self.load_state_dict(chkpt, strict=False))\n\n    def _get_pos_embed(self, hw: Tuple[int, int]) -> torch.Tensor:\n        h, w = hw\n        window_embed = self.pos_embed_window\n        pos_embed = F.interpolate(self.pos_embed, size=(h, w), mode="bicubic")\n        pos_embed = pos_embed + window_embed.tile(\n            [x // y for x, y in zip(pos_embed.shape, window_embed.shape)]\n        )\n        pos_embed = pos_embed.permute(0, 2, 3, 1)\n        return pos_embed\n\n    def forward(self, x: torch.Tensor) -> List[torch.Tensor]:\n        x = self.patch_embed(x)\n        # x: (B, H, W, C)\n\n        # Add pos embed\n        x = x + self._get_pos_embed(x.shape[1:3])\n\n        outputs = []\n        for i, blk in enumerate(self.blocks):\n            x = blk(x)\n            if (i == self.stage_ends[-1]) or (\n                i in self.stage_ends and self.return_interm_layers\n            ):\n                feats = x.permute(0, 3, 1, 2)\n                outputs.append(feats)\n\n        return outputs\n\n    def get_layer_id(self, layer_name):\n        # https://github.com/microsoft/unilm/blob/master/beit/optim_factory.py#L33\n        num_layers = self.get_num_layers()\n\n        if layer_name.find("rel_pos") != -1:\n            return num_layers + 1\n        elif layer_name.find("pos_embed") != -1:\n            return 0\n        elif layer_name.find("patch_embed") != -1:\n            return 0\n        elif layer_name.find("blocks") != -1:\n            return int(layer_name.split("blocks")[1].split(".")[1]) + 1\n        else:\n            return num_layers + 1\n\n    def get_num_layers(self) -> int:\n        return len(self.blocks)\n',
    'sam2.modeling.backbones.image_encoder': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Optional\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom efficient_track_anything.modeling.efficienttam_utils import LayerNorm2d\n\n\n\nclass ImageEncoder(nn.Module):\n    def __init__(\n        self,\n        trunk: nn.Module,\n        neck: nn.Module,\n        scalp: int = 0,\n    ):\n        super().__init__()\n        self.trunk = trunk\n        self.neck = neck\n        self.scalp = scalp\n        assert (\n            self.trunk.channel_list == self.neck.backbone_channel_list\n        ), f"Channel dims of trunk and neck do not match. Trunk: {self.trunk.channel_list}, neck: {self.neck.backbone_channel_list}"\n\n    def forward(self, sample: torch.Tensor):\n        # Forward through backbone\n        features, pos = self.neck(self.trunk(sample))\n        if self.scalp > 0:\n            # Discard the lowest resolution features\n            features, pos = features[: -self.scalp], pos[: -self.scalp]\n\n        src = features[-1]\n        output = {\n            "vision_features": src,\n            "vision_pos_enc": pos,\n            "backbone_fpn": features,\n        }\n        return output\n\n\nclass FpnNeck(nn.Module):\n    """\n    A modified variant of Feature Pyramid Network (FPN) neck\n    (we remove output conv and also do bicubic interpolation similar to ViT\n    pos embed interpolation)\n    """\n\n    def __init__(\n        self,\n        position_encoding: nn.Module,\n        d_model: int,\n        backbone_channel_list: List[int],\n        kernel_size: int = 1,\n        stride: int = 1,\n        padding: int = 0,\n        fpn_interp_model: str = "bilinear",\n        fuse_type: str = "sum",\n        fpn_top_down_levels: Optional[List[int]] = None,\n    ):\n        """Initialize the neck\n        :param trunk: the backbone\n        :param position_encoding: the positional encoding to use\n        :param d_model: the dimension of the model\n        :param neck_norm: the normalization to use\n        """\n        super().__init__()\n        self.position_encoding = position_encoding\n        self.convs = nn.ModuleList()\n        self.backbone_channel_list = backbone_channel_list\n        self.d_model = d_model\n        for dim in backbone_channel_list:\n            current = nn.Sequential()\n            current.add_module(\n                "conv",\n                nn.Conv2d(\n                    in_channels=dim,\n                    out_channels=d_model,\n                    kernel_size=kernel_size,\n                    stride=stride,\n                    padding=padding,\n                ),\n            )\n\n            self.convs.append(current)\n        self.fpn_interp_model = fpn_interp_model\n        assert fuse_type in ["sum", "avg"]\n        self.fuse_type = fuse_type\n\n        # levels to have top-down features in its outputs\n        # e.g. if fpn_top_down_levels is [2, 3], then only outputs of level 2 and 3\n        # have top-down propagation, while outputs of level 0 and level 1 have only\n        # lateral features from the same backbone level.\n        if fpn_top_down_levels is None:\n            # default is to have top-down features on all levels\n            fpn_top_down_levels = range(len(self.convs))\n        self.fpn_top_down_levels = list(fpn_top_down_levels)\n\n    def forward(self, xs: List[torch.Tensor]):\n\n        out = [None] * len(self.convs)\n        pos = [None] * len(self.convs)\n        assert len(xs) == len(self.convs)\n        # fpn forward pass\n        # see https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/fpn.py\n        prev_features = None\n        # forward in top-down order (from low to high resolution)\n        n = len(self.convs) - 1\n        for i in range(n, -1, -1):\n            x = xs[i]\n            lateral_features = self.convs[n - i](x)\n            if i in self.fpn_top_down_levels and prev_features is not None:\n                top_down_features = F.interpolate(\n                    prev_features.to(dtype=torch.float32),\n                    scale_factor=2.0,\n                    mode=self.fpn_interp_model,\n                    align_corners=(\n                        None if self.fpn_interp_model == "nearest" else False\n                    ),\n                    antialias=False,\n                )\n                prev_features = lateral_features + top_down_features\n                if self.fuse_type == "avg":\n                    prev_features /= 2\n            else:\n                prev_features = lateral_features\n            x_out = prev_features\n            out[i] = x_out\n            pos[i] = self.position_encoding(x_out).to(x_out.dtype)\n\n        return out, pos\n\n\nclass ViTDetNeck(nn.Module):\n    def __init__(\n        self,\n        position_encoding: nn.Module,\n        d_model: int,\n        backbone_channel_list: List[int],\n        kernel_size: int = 1,\n        stride: int = 1,\n        padding: int = 0,\n        neck_norm=None,\n    ):\n        """Initialize the neck\n\n        :param trunk: the backbone\n        :param position_encoding: the positional encoding to use\n        :param d_model: the dimension of the model\n        :param neck_norm: the normalization to use\n        """\n        super().__init__()\n        self.backbone_channel_list = backbone_channel_list\n        self.position_encoding = position_encoding\n        self.convs = nn.ModuleList()\n        self.d_model = d_model\n        use_bias = neck_norm is None\n        for dim in self.backbone_channel_list:\n            current = nn.Sequential()\n            current.add_module(\n                "conv_1x1",\n                nn.Conv2d(\n                    in_channels=dim,\n                    out_channels=d_model,\n                    kernel_size=1,\n                    bias=use_bias,\n                ),\n            )\n            if neck_norm is not None:\n                current.add_module("norm_0", LayerNorm2d(d_model))\n            current.add_module(\n                "conv_3x3",\n                nn.Conv2d(\n                    in_channels=d_model,\n                    out_channels=d_model,\n                    kernel_size=3,\n                    padding=1,\n                    bias=use_bias,\n                ),\n            )\n            if neck_norm is not None:\n                current.add_module("norm_1", LayerNorm2d(d_model))\n            self.convs.append(current)\n\n    def forward(self, xs: List[torch.Tensor]):\n        out = [None] * len(self.convs)\n        pos = [None] * len(self.convs)\n        assert len(xs) == len(self.convs)\n\n        x = xs[0]\n        x_out = self.convs[0](x)\n        out[0] = x_out\n        pos[0] = self.position_encoding(x_out).to(x_out.dtype)\n\n        return out, pos\n\n\n',
    'sam2.modeling.backbones.utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n"""Some utilities for backbones, in particular for windowing"""\n\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nimport math\n\ndef window_partition(x, window_size):\n    """\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    """\n    B, H, W, C = x.shape\n\n    pad_h = (window_size - H % window_size) % window_size\n    pad_w = (window_size - W % window_size) % window_size\n    if pad_h > 0 or pad_w > 0:\n        x = F.pad(x, (0, 0, 0, pad_w, 0, pad_h))\n    Hp, Wp = H + pad_h, W + pad_w\n\n    x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)\n    windows = x.permute(0, 1, 3, 2, 4, 5).reshape(-1, window_size, window_size, C)\n    return windows, (Hp, Wp)\n\n\ndef window_unpartition(windows, window_size, pad_hw, hw):\n    """\n    Window unpartition into original sequences and removing padding.\n    Args:\n        x (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.\n    Returns:\n        x: unpartitioned sequences with [B, H, W, C].\n    """\n    Hp, Wp = pad_hw\n    H, W = hw\n    B = windows.shape[0] // (Hp * Wp // window_size // window_size)\n    x = windows.reshape(\n        B, Hp // window_size, Wp // window_size, window_size, window_size, -1\n    )\n    x = x.permute(0, 1, 3, 2, 4, 5).reshape(B, Hp, Wp, -1)\n\n    if Hp > H or Wp > W:\n        x = x[:, :H, :W, :]\n    return x\n\n\nclass PatchEmbed(nn.Module):\n    """\n    Image to Patch Embedding.\n    """\n\n    def __init__(\n        self,\n        kernel_size: Tuple[int, ...] = (7, 7),\n        stride: Tuple[int, ...] = (4, 4),\n        padding: Tuple[int, ...] = (3, 3),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ):\n        """\n        Args:\n            kernel_size (Tuple): kernel size of the projection layer.\n            stride (Tuple): stride of the projection layer.\n            padding (Tuple): padding size of the projection layer.\n            in_chans (int): Number of input image channels.\n            embed_dim (int):  embed_dim (int): Patch embedding dimension.\n        """\n        super().__init__()\n        self.proj = nn.Conv2d(\n            in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.proj(x)\n        # B C H W -> B H W C\n        x = x.permute(0, 2, 3, 1)\n        return x\n\n\ndef get_abs_pos(abs_pos, has_cls_token, hw):\n    """\n    Calculate absolute positional embeddings. If needed, resize embeddings and remove cls_token\n        dimension for the original embeddings.\n    Args:\n        abs_pos (Tensor): absolute positional embeddings with (1, num_position, C).\n        has_cls_token (bool): If true, has 1 embedding in abs_pos for cls token.\n        hw (Tuple): size of input image tokens.\n    Returns:\n        Absolute positional embeddings after processing with shape (1, H, W, C)\n    """\n    h, w = hw\n    if has_cls_token:\n        abs_pos = abs_pos[:, 1:]\n    xy_num = abs_pos.shape[1]\n    size = int(math.sqrt(xy_num))\n    assert size * size == xy_num\n\n    if size != h or size != w:\n        interpolate_mode = "bicubic"\n        if not torch.cuda.is_available() and torch.mps.is_available():\n            # bicubic is not supported on torch mps\n            interpolate_mode = "bilinear"\n        new_abs_pos = F.interpolate(\n            abs_pos.reshape(1, size, size, -1).permute(0, 3, 1, 2),\n            size=(h, w),\n            mode=interpolate_mode,\n            align_corners=False,\n        )\n        return new_abs_pos.permute(0, 2, 3, 1)\n    else:\n        return abs_pos.reshape(1, h, w, -1)\n',
    'sam2.modeling.backbones.vitdet': '"""ViTDet backbone adapted from Detectron2"""\n\nfrom functools import partial\nfrom typing import List, Tuple, Union\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom sam2.modeling.backbones.utils import (\n    get_abs_pos,\n    PatchEmbed,\n    window_partition,\n    window_unpartition,\n)\n\nfrom sam2.modeling.efficienttam_utils import (\n    DropPath,\n    LayerScale,\n    MLP,\n)\n\n\nclass Attention(nn.Module):\n    """Multi-head Attention block with relative position embeddings."""\n\n    def __init__(\n        self,\n        dim,\n        num_heads=8,\n        qkv_bias=True,\n        use_rel_pos=False,\n        rel_pos_zero_init=True,\n        input_size=None,\n    ):\n        """\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads.\n            qkv_bias (bool:  If True, add a learnable bias to query, key, value.\n            rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            input_size (int or None): Input resolution for calculating the relative positional\n                parameter size.\n            attn_type: Type of attention operation, e.g. "vanilla", "vanilla-xformer".\n        """\n        super().__init__()\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = head_dim**-0.5\n\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.proj = nn.Linear(dim, dim)\n\n        self.use_rel_pos = use_rel_pos\n\n    def forward(self, x):\n        B, H, W, _ = x.shape\n        # qkv with shape (3, B, nHead, H * W, C)\n        qkv = (\n            self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4)\n        )\n        # q, k, v with shape (B * nHead, H * W, C)\n        q, k, v = qkv.reshape(3, B * self.num_heads, H * W, -1).unbind(0)\n\n        q = q.view(B, self.num_heads, H * W, -1)\n        k = k.view(B, self.num_heads, H * W, -1)\n        v = v.view(B, self.num_heads, H * W, -1)\n\n        x = F.scaled_dot_product_attention(q, k, v)\n\n        x = (\n            x.view(B, self.num_heads, H, W, -1)\n            .permute(0, 2, 3, 1, 4)\n            .reshape(B, H, W, -1)\n        )\n        x = self.proj(x)\n\n        return x\n\n\nclass Block(nn.Module):\n    """Transformer blocks with support of window attention"""\n\n    def __init__(\n        self,\n        dim,\n        num_heads,\n        mlp_ratio=4.0,\n        qkv_bias=True,\n        drop_path=0.0,\n        norm_layer=nn.LayerNorm,\n        act_layer=nn.GELU,\n        use_rel_pos=False,\n        rel_pos_zero_init=True,\n        window_size=0,\n        input_size=None,\n        dropout=0.0,\n        init_values=None,\n    ):\n        """\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            drop_path (float): Stochastic depth rate.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks. If it equals 0, then not\n                use window attention.\n            input_size (int or None): Input resolution for calculating the relative positional\n                parameter size.\n            dropout (float): Dropout rate.\n        """\n        super().__init__()\n        self.norm1 = norm_layer(dim)\n        self.attn = Attention(\n            dim,\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            use_rel_pos=use_rel_pos,\n            rel_pos_zero_init=rel_pos_zero_init,\n            input_size=input_size if window_size == 0 else (window_size, window_size),\n        )\n        self.ls1 = (\n            LayerScale(dim, init_values=init_values) if init_values else nn.Identity()\n        )\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n\n        self.norm2 = norm_layer(dim)\n        self.mlp = MLP(\n            dim,\n            int(dim * mlp_ratio),\n            dim,\n            num_layers=2,\n            activation=act_layer,\n        )\n        self.ls2 = (\n            LayerScale(dim, init_values=init_values) if init_values else nn.Identity()\n        )\n        self.dropout = nn.Dropout(dropout)\n        self.window_size = window_size\n\n    def forward(self, x):\n        shortcut = x\n        x = self.norm1(x)\n        # Window partition\n        if self.window_size > 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, self.window_size)\n\n        x = self.ls1(self.attn(x))\n        # Reverse window partition\n        if self.window_size > 0:\n            x = window_unpartition(x, self.window_size, pad_hw, (H, W))\n\n        x = shortcut + self.dropout(self.drop_path(x))\n        x = x + self.dropout(self.drop_path(self.ls2(self.mlp(self.norm2(x)))))\n\n        return x\n\n\nclass ViT(nn.Module):\n    """\n    This module implements Vision Transformer (ViT) backbone in :paper:`vitdet`.\n    "Exploring Plain Vision Transformer Backbones for Object Detection",\n    https://arxiv.org/abs/2203.16527\n    """\n\n    def __init__(\n        self,\n        img_size=1024,\n        patch_size=16,\n        in_chans=3,\n        embed_dim=768,\n        depth=12,\n        num_heads=12,\n        mlp_ratio=4.0,\n        qkv_bias=True,\n        drop_path_rate=0.0,\n        norm_layer=partial(nn.LayerNorm, eps=1e-6),\n        act_layer=nn.GELU,\n        use_abs_pos=True,\n        use_rel_pos=False,\n        rel_pos_zero_init=True,\n        window_size=14,\n        window_block_indexes=(0, 1, 3, 4, 6, 7, 9, 10),\n        use_act_checkpoint=False,\n        pretrain_img_size=224,\n        pretrain_use_cls_token=True,\n        dropout=0.0,\n        weights_path=None,\n        return_interm_layers=False,\n        init_values=None,\n    ):\n        """\n        Args:\n            img_size (int): Input image size. Only relevant for rel pos.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            drop_path_rate (float): Stochastic depth rate.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_abs_pos (bool): If True, use absolute positional embeddings.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks.\n            window_block_indexes (list): Indexes for blocks using window attention.\n            residual_block_indexes (list): Indexes for blocks using conv propagation.\n            use_act_checkpoint (bool): If True, use activation checkpointing.\n            pretrain_img_size (int): input image size for pretraining models.\n            pretrain_use_cls_token (bool): If True, pretrainig models use class token.\n            dropout (float): Dropout rate. Applied in residual blocks of attn, mlp and inside the mlp.\n            path (str or None): Path to the pretrained weights.\n            return_interm_layers (bool): Whether to return intermediate layers (all global attention blocks).\n            freezing (BackboneFreezingType): Type of freezing.\n        """\n        super().__init__()\n        self.pretrain_use_cls_token = pretrain_use_cls_token\n\n        self.patch_embed = PatchEmbed(\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            padding=(0, 0),\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n        )\n\n        if use_abs_pos:\n            # Initialize absolute positional embedding with pretrain image size.\n            num_patches = (pretrain_img_size // patch_size) * (\n                pretrain_img_size // patch_size\n            )\n            num_positions = (num_patches + 1) if pretrain_use_cls_token else num_patches\n            self.pos_embed = nn.Parameter(torch.zeros(1, num_positions, embed_dim))\n        else:\n            self.pos_embed = None\n\n        # stochastic depth decay rule\n        dpr = [x.item() for x in torch.linspace(0, drop_path_rate, depth)]\n\n        self.blocks = nn.ModuleList()\n        self.full_attn_ids = []\n        cur_stage = 1\n        for i in range(depth):\n            block = Block(\n                dim=embed_dim,\n                num_heads=num_heads,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                drop_path=dpr[i],\n                norm_layer=norm_layer,\n                act_layer=act_layer,\n                use_rel_pos=use_rel_pos,\n                rel_pos_zero_init=rel_pos_zero_init,\n                window_size=window_size if i in window_block_indexes else 0,\n                input_size=(img_size // patch_size, img_size // patch_size),\n                dropout=dropout,\n                init_values=init_values,\n            )\n            if i not in window_block_indexes:\n                self.full_attn_ids.append(i)\n                cur_stage += 1\n\n            self.blocks.append(block)\n\n        self.return_interm_layers = return_interm_layers\n        self.channel_list = (\n            [embed_dim] * len(self.full_attn_ids)\n            if return_interm_layers\n            else [embed_dim]\n        )\n\n    def forward(self, x: torch.Tensor) -> List[torch.Tensor]:\n\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + get_abs_pos(\n                self.pos_embed, self.pretrain_use_cls_token, (x.shape[1], x.shape[2])\n            )\n\n        outputs = []\n        for i, blk in enumerate(self.blocks):\n            x = blk(x)\n            if (i == self.full_attn_ids[-1]) or (\n                self.return_interm_layers and i in self.full_attn_ids\n            ):\n                feats = x.permute(0, 3, 1, 2)\n                outputs.append(feats)\n\n        return outputs\n    \n    def get_num_layers(self):\n        return len(self.blocks)\n    \n    def get_layer_id(self, layer_name):\n        # https://github.com/microsoft/unilm/blob/master/beit/optim_factory.py#L33\n        num_layers = self.get_num_layers()\n\n        if layer_name.find("rel_pos") != -1:\n            return num_layers + 1\n        elif layer_name.find("pos_embed") != -1:\n            return 0\n        elif layer_name.find("patch_embed") != -1:\n            return 0\n        elif layer_name.find("blocks") != -1:\n            return int(layer_name.split("blocks")[1].split(".")[1]) + 1\n        else:\n            return num_layers + 1\n',
    'sam2.modeling.efficienttam_base': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\nimport torch.distributed\nimport torch.nn.functional as F\nfrom sam2.modeling.efficienttam_utils import (\n    get_1d_sine_pe,\n    MLP,\n    select_closest_cond_frames,\n)\n\nfrom sam2.modeling.sam.mask_decoder import MaskDecoder\nfrom sam2.modeling.sam.prompt_encoder import PromptEncoder\nfrom sam2.modeling.sam.transformer import TwoWayTransformer\n\nfrom torch.nn.init import trunc_normal_\n\n# a large negative value as a placeholder score for missing objects\nNO_OBJ_SCORE = -1024.0\n\n\nclass EfficientTAMBase(torch.nn.Module):\n    def __init__(\n        self,\n        image_encoder,\n        memory_attention,\n        memory_encoder,\n        num_maskmem=7,  # default 1 input frame + 6 previous frames\n        image_size=512,\n        backbone_stride=16,  # stride of the image backbone output\n        sigmoid_scale_for_mem_enc=1.0,  # scale factor for mask sigmoid prob\n        sigmoid_bias_for_mem_enc=0.0,  # bias factor for mask sigmoid prob\n        # During evaluation, whether to binarize the sigmoid mask logits on interacted frames with clicks\n        binarize_mask_from_pts_for_mem_enc=False,\n        use_mask_input_as_output_without_sam=False,  # on frames with mask input, whether to directly output the input mask without using a SAM prompt encoder + mask decoder\n        # The maximum number of conditioning frames to participate in the memory attention (-1 means no limit; if there are more conditioning frames than this limit,\n        # we only cross-attend to the temporally closest `max_cond_frames_in_attn` conditioning frames in the encoder when tracking each frame). This gives the model\n        # a temporal locality when handling a large number of annotated frames (since closer frames should be more important) and also avoids GPU OOM.\n        max_cond_frames_in_attn=-1,\n        # on the first frame, whether to directly add the no-memory embedding to the image feature\n        # (instead of using the transformer encoder)\n        directly_add_no_mem_embed=False,\n        # whether to use high-resolution feature maps in the SAM mask decoder\n        use_high_res_features_in_sam=False,\n        # whether to output multiple (3) masks for the first click on initial conditioning frames\n        multimask_output_in_sam=False,\n        # the minimum and maximum number of clicks to use multimask_output_in_sam (only relevant when `multimask_output_in_sam=True`;\n        # default is 1 for both, meaning that only the first click gives multimask output; also note that a box counts as two points)\n        multimask_min_pt_num=1,\n        multimask_max_pt_num=1,\n        # whether to also use multimask output for tracking (not just for the first click on initial conditioning frames; only relevant when `multimask_output_in_sam=True`)\n        multimask_output_for_tracking=False,\n        # Whether to use multimask tokens for obj ptr; Only relevant when both\n        # use_obj_ptrs_in_encoder=True and multimask_output_for_tracking=True\n        use_multimask_token_for_obj_ptr: bool = False,\n        # whether to use sigmoid to restrict ious prediction to [0-1]\n        iou_prediction_use_sigmoid=False,\n        # The memory bank\'s temporal stride during evaluation (i.e. the `r` parameter in XMem and Cutie; XMem and Cutie use r=5).\n        # For r>1, the (self.num_maskmem - 1) non-conditioning memory frames consist of\n        # (self.num_maskmem - 2) nearest frames from every r-th frames, plus the last frame.\n        memory_temporal_stride_for_eval=1,\n        # whether to apply non-overlapping constraints on the object masks in the memory encoder during evaluation (to avoid/alleviate superposing masks)\n        non_overlap_masks_for_mem_enc=False,\n        # whether to cross-attend to object pointers from other frames (based on SAM output tokens) in the encoder\n        use_obj_ptrs_in_encoder=False,\n        # the maximum number of object pointers from other frames in encoder cross attention (only relevant when `use_obj_ptrs_in_encoder=True`)\n        max_obj_ptrs_in_encoder=16,\n        # whether to add temporal positional encoding to the object pointers in the encoder (only relevant when `use_obj_ptrs_in_encoder=True`)\n        add_tpos_enc_to_obj_ptrs=True,\n        # whether to add an extra linear projection layer for the temporal positional encoding in the object pointers to avoid potential interference\n        # with spatial positional encoding (only relevant when both `use_obj_ptrs_in_encoder=True` and `add_tpos_enc_to_obj_ptrs=True`)\n        proj_tpos_enc_in_obj_ptrs=False,\n        # whether to use signed distance (instead of unsigned absolute distance) in the temporal positional encoding in the object pointers\n        # (only relevant when both `use_obj_ptrs_in_encoder=True` and `add_tpos_enc_to_obj_ptrs=True`)\n        use_signed_tpos_enc_to_obj_ptrs=False,\n        # whether to only attend to object pointers in the past (before the current frame) in the encoder during evaluation\n        # (only relevant when `use_obj_ptrs_in_encoder=True`; this might avoid pointer information too far in the future to distract the initial tracking)\n        only_obj_ptrs_in_the_past_for_eval=False,\n        # Whether to predict if there is an object in the frame\n        pred_obj_scores: bool = False,\n        # Whether to use an MLP to predict object scores\n        pred_obj_scores_mlp: bool = False,\n        # Only relevant if pred_obj_scores=True and use_obj_ptrs_in_encoder=True;\n        # Whether to have a fixed no obj pointer when there is no object present\n        # or to use it as an additive embedding with obj_ptr produced by decoder\n        fixed_no_obj_ptr: bool = False,\n        # Soft no object, i.e. mix in no_obj_ptr softly,\n        # hope to make recovery easier if there is a mistake and mitigate accumulation of errors\n        soft_no_obj_ptr: bool = False,\n        use_mlp_for_obj_ptr_proj: bool = False,\n        # add no obj embedding to spatial frames\n        no_obj_embed_spatial: bool = False,\n        # extra arguments used to construct the SAM mask decoder; if not None, it should be a dict of kwargs to be passed into `MaskDecoder` class.\n        sam_mask_decoder_extra_args=None,\n        compile_image_encoder: bool = False,\n    ):\n        super().__init__()\n\n        # Part 1: the image backbone\n        self.image_encoder = image_encoder\n        self.use_high_res_features_in_sam = False\n        self.num_feature_levels = 1\n        self.use_obj_ptrs_in_encoder = use_obj_ptrs_in_encoder\n        self.max_obj_ptrs_in_encoder = max_obj_ptrs_in_encoder\n        if use_obj_ptrs_in_encoder:\n            # A conv layer to downsample the mask prompt to stride 4 (the same stride as\n            # low-res SAM mask logits) and to change its scales from 0~1 to SAM logit scale,\n            # so that it can be fed into the SAM mask decoder to generate a pointer.\n            self.mask_downsample = torch.nn.Conv2d(1, 1, kernel_size=4, stride=4)\n        self.add_tpos_enc_to_obj_ptrs = add_tpos_enc_to_obj_ptrs\n        if proj_tpos_enc_in_obj_ptrs:\n            assert add_tpos_enc_to_obj_ptrs  # these options need to be used together\n        self.proj_tpos_enc_in_obj_ptrs = proj_tpos_enc_in_obj_ptrs\n        self.use_signed_tpos_enc_to_obj_ptrs = use_signed_tpos_enc_to_obj_ptrs\n        self.only_obj_ptrs_in_the_past_for_eval = only_obj_ptrs_in_the_past_for_eval\n\n        # Part 2: memory attention to condition current frame\'s visual features\n        # with memories (and obj ptrs) from past frames\n        self.memory_attention = memory_attention\n        self.hidden_dim = image_encoder.neck.d_model\n\n        # Part 3: memory encoder for the previous frame\'s outputs\n        self.memory_encoder = memory_encoder\n        self.mem_dim = self.hidden_dim\n        if hasattr(self.memory_encoder, "out_proj") and hasattr(\n            self.memory_encoder.out_proj, "weight"\n        ):\n            # if there is compression of memories along channel dim\n            self.mem_dim = self.memory_encoder.out_proj.weight.shape[0]\n        self.num_maskmem = num_maskmem  # Number of memories accessible\n        # Temporal encoding of the memories\n        self.maskmem_tpos_enc = torch.nn.Parameter(\n            torch.zeros(num_maskmem, 1, 1, self.mem_dim)\n        )\n        trunc_normal_(self.maskmem_tpos_enc, std=0.02)\n        # a single token to indicate no memory embedding from previous frames\n        self.no_mem_embed = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        self.no_mem_pos_enc = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        trunc_normal_(self.no_mem_embed, std=0.02)\n        trunc_normal_(self.no_mem_pos_enc, std=0.02)\n        self.directly_add_no_mem_embed = directly_add_no_mem_embed\n        # Apply sigmoid to the output raw mask logits (to turn them from\n        # range (-inf, +inf) to range (0, 1)) before feeding them into the memory encoder\n        self.sigmoid_scale_for_mem_enc = sigmoid_scale_for_mem_enc\n        self.sigmoid_bias_for_mem_enc = sigmoid_bias_for_mem_enc\n        self.binarize_mask_from_pts_for_mem_enc = binarize_mask_from_pts_for_mem_enc\n        self.non_overlap_masks_for_mem_enc = non_overlap_masks_for_mem_enc\n        self.memory_temporal_stride_for_eval = memory_temporal_stride_for_eval\n        # On frames with mask input, whether to directly output the input mask without\n        # using a SAM prompt encoder + mask decoder\n        self.use_mask_input_as_output_without_sam = use_mask_input_as_output_without_sam\n        self.multimask_output_in_sam = multimask_output_in_sam\n        self.multimask_min_pt_num = multimask_min_pt_num\n        self.multimask_max_pt_num = multimask_max_pt_num\n        self.multimask_output_for_tracking = multimask_output_for_tracking\n        self.use_multimask_token_for_obj_ptr = use_multimask_token_for_obj_ptr\n        self.iou_prediction_use_sigmoid = iou_prediction_use_sigmoid\n\n        # Part 4: SAM-style prompt encoder (for both mask and point inputs)\n        # and SAM-style mask decoder for the final mask output\n        self.image_size = image_size\n        self.backbone_stride = backbone_stride\n        self.sam_mask_decoder_extra_args = sam_mask_decoder_extra_args\n        self.pred_obj_scores = pred_obj_scores\n        self.pred_obj_scores_mlp = pred_obj_scores_mlp\n        self.fixed_no_obj_ptr = fixed_no_obj_ptr\n        self.soft_no_obj_ptr = soft_no_obj_ptr\n        if self.fixed_no_obj_ptr:\n            assert self.pred_obj_scores\n            assert self.use_obj_ptrs_in_encoder\n        if self.pred_obj_scores and self.use_obj_ptrs_in_encoder:\n            self.no_obj_ptr = torch.nn.Parameter(torch.zeros(1, self.hidden_dim))\n            trunc_normal_(self.no_obj_ptr, std=0.02)\n        self.use_mlp_for_obj_ptr_proj = use_mlp_for_obj_ptr_proj\n        self.no_obj_embed_spatial = None\n        if no_obj_embed_spatial:\n            self.no_obj_embed_spatial = torch.nn.Parameter(torch.zeros(1, self.mem_dim))\n            trunc_normal_(self.no_obj_embed_spatial, std=0.02)\n\n        self._build_sam_heads()\n        self.max_cond_frames_in_attn = max_cond_frames_in_attn\n\n        # Model compilation\n        if compile_image_encoder:\n            # Compile the forward function (not the full module) to allow loading checkpoints.\n            print(\n                "Image encoder compilation is enabled. First forward pass will be slow."\n            )\n            self.image_encoder.forward = torch.compile(\n                self.image_encoder.forward,\n                mode="max-autotune",\n                fullgraph=True,\n                dynamic=False,\n            )\n\n    @property\n    def device(self):\n        return next(self.parameters()).device\n\n    def forward(self, *args, **kwargs):\n        raise NotImplementedError(\n            "Please use the corresponding methods in EfficientTAMVideoPredictor for inference"\n        )\n\n    def _build_sam_heads(self):\n        """Build SAM-style prompt encoder and mask decoder."""\n        self.sam_prompt_embed_dim = self.hidden_dim\n        self.sam_image_embedding_size = self.image_size // self.backbone_stride\n\n        # build PromptEncoder and MaskDecoder from SAM\n        # (their hyperparameters like `mask_in_chans=16` are from SAM code)\n        self.sam_prompt_encoder = PromptEncoder(\n            embed_dim=self.sam_prompt_embed_dim,\n            image_embedding_size=(\n                self.sam_image_embedding_size,\n                self.sam_image_embedding_size,\n            ),\n            input_image_size=(self.image_size, self.image_size),\n            mask_in_chans=16,\n        )\n        self.sam_mask_decoder = MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=self.sam_prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=self.sam_prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n            use_high_res_features=self.use_high_res_features_in_sam,\n            iou_prediction_use_sigmoid=self.iou_prediction_use_sigmoid,\n            pred_obj_scores=self.pred_obj_scores,\n            pred_obj_scores_mlp=self.pred_obj_scores_mlp,\n            use_multimask_token_for_obj_ptr=self.use_multimask_token_for_obj_ptr,\n            **(self.sam_mask_decoder_extra_args or {}),\n        )\n        if self.use_obj_ptrs_in_encoder:\n            # a linear projection on SAM output tokens to turn them into object pointers\n            self.obj_ptr_proj = torch.nn.Linear(self.hidden_dim, self.hidden_dim)\n            if self.use_mlp_for_obj_ptr_proj:\n                self.obj_ptr_proj = MLP(\n                    self.hidden_dim, self.hidden_dim, self.hidden_dim, 3\n                )\n        else:\n            self.obj_ptr_proj = torch.nn.Identity()\n        if self.proj_tpos_enc_in_obj_ptrs:\n            # a linear projection on temporal positional encoding in object pointers to\n            # avoid potential interference with spatial positional encoding\n            self.obj_ptr_tpos_proj = torch.nn.Linear(self.hidden_dim, self.mem_dim)\n        else:\n            self.obj_ptr_tpos_proj = torch.nn.Identity()\n\n    def _forward_sam_heads(\n        self,\n        backbone_features,\n        point_inputs=None,\n        mask_inputs=None,\n        high_res_features=None,\n        multimask_output=False,\n    ):\n        """\n        Forward SAM prompt encoders and mask heads.\n\n        Inputs:\n        - backbone_features: image features of [B, C, H, W] shape\n        - point_inputs: a dictionary with "point_coords" and "point_labels", where\n          1) "point_coords" has [B, P, 2] shape and float32 dtype and contains the\n             absolute pixel-unit coordinate in (x, y) format of the P input points\n          2) "point_labels" has shape [B, P] and int32 dtype, where 1 means\n             positive clicks, 0 means negative clicks, and -1 means padding\n        - mask_inputs: a mask of [B, 1, H*16, W*16] shape, float or bool, with the\n          same spatial size as the image.\n        - high_res_features: either 1) None or 2) or a list of length 2 containing\n          two feature maps of [B, C, 4*H, 4*W] and [B, C, 2*H, 2*W] shapes respectively,\n          which will be used as high-resolution feature maps for SAM decoder.\n        - multimask_output: if it\'s True, we output 3 candidate masks and their 3\n          corresponding IoU estimates, and if it\'s False, we output only 1 mask and\n          its corresponding IoU estimate.\n\n        Outputs:\n        - low_res_multimasks: [B, M, H*4, W*4] shape (where M = 3 if\n          `multimask_output=True` and M = 1 if `multimask_output=False`), the SAM\n          output mask logits (before sigmoid) for the low-resolution masks, with 4x\n          the resolution (1/4 stride) of the input backbone_features.\n        - high_res_multimasks: [B, M, H*16, W*16] shape (where M = 3\n          if `multimask_output=True` and M = 1 if `multimask_output=False`),\n          upsampled from the low-resolution masks, with shape size as the image\n          (stride is 1 pixel).\n        - ious, [B, M] shape, where (where M = 3 if `multimask_output=True` and M = 1\n          if `multimask_output=False`), the estimated IoU of each output mask.\n        - low_res_masks: [B, 1, H*4, W*4] shape, the best mask in `low_res_multimasks`.\n          If `multimask_output=True`, it\'s the mask with the highest IoU estimate.\n          If `multimask_output=False`, it\'s the same as `low_res_multimasks`.\n        - high_res_masks: [B, 1, H*16, W*16] shape, the best mask in `high_res_multimasks`.\n          If `multimask_output=True`, it\'s the mask with the highest IoU estimate.\n          If `multimask_output=False`, it\'s the same as `high_res_multimasks`.\n        - obj_ptr: [B, C] shape, the object pointer vector for the output mask, extracted\n          based on the output token from the SAM mask decoder.\n        """\n        B = backbone_features.size(0)\n        device = backbone_features.device\n        assert backbone_features.size(1) == self.sam_prompt_embed_dim\n        assert backbone_features.size(2) == self.sam_image_embedding_size\n        assert backbone_features.size(3) == self.sam_image_embedding_size\n\n        # a) Handle point prompts\n        if point_inputs is not None:\n            sam_point_coords = point_inputs["point_coords"]\n            sam_point_labels = point_inputs["point_labels"]\n            assert sam_point_coords.size(0) == B and sam_point_labels.size(0) == B\n        else:\n            # If no points are provide, pad with an empty point (with label -1)\n            sam_point_coords = torch.zeros(B, 1, 2, device=device)\n            sam_point_labels = -torch.ones(B, 1, dtype=torch.int32, device=device)\n\n        # b) Handle mask prompts\n        if mask_inputs is not None:\n            # If mask_inputs is provided, downsize it into low-res mask input if needed\n            # and feed it as a dense mask prompt into the SAM mask encoder\n            assert len(mask_inputs.shape) == 4 and mask_inputs.shape[:2] == (B, 1)\n            if mask_inputs.shape[-2:] != self.sam_prompt_encoder.mask_input_size:\n                sam_mask_prompt = F.interpolate(\n                    mask_inputs.float(),\n                    size=self.sam_prompt_encoder.mask_input_size,\n                    align_corners=False,\n                    mode="bilinear",\n                    antialias=True,  # use antialias for downsampling\n                )\n            else:\n                sam_mask_prompt = mask_inputs\n        else:\n            # Otherwise, simply feed None (and SAM\'s prompt encoder will add\n            # a learned `no_mask_embed` to indicate no mask input in this case).\n            sam_mask_prompt = None\n\n        sparse_embeddings, dense_embeddings = self.sam_prompt_encoder(\n            points=(sam_point_coords, sam_point_labels),\n            boxes=None,\n            masks=sam_mask_prompt,\n        )\n        (\n            low_res_multimasks,\n            ious,\n            sam_output_tokens,\n            object_score_logits,\n        ) = self.sam_mask_decoder(\n            image_embeddings=backbone_features,\n            image_pe=self.sam_prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n            repeat_image=False,  # the image is already batched\n            high_res_features=high_res_features,\n        )\n        if self.pred_obj_scores:\n            is_obj_appearing = object_score_logits > 0\n\n            # Mask used for spatial memories is always a *hard* choice between obj and no obj,\n            # consistent with the actual mask prediction\n            low_res_multimasks = torch.where(\n                is_obj_appearing[:, None, None],\n                low_res_multimasks,\n                NO_OBJ_SCORE,\n            )\n\n        # convert masks from possibly bfloat16 (or float16) to float32\n        # (older PyTorch versions before 2.1 don\'t support `interpolate` on bf16)\n        low_res_multimasks = low_res_multimasks.float()\n        high_res_multimasks = F.interpolate(\n            low_res_multimasks,\n            size=(self.image_size, self.image_size),\n            mode="bilinear",\n            align_corners=False,\n        )\n\n        sam_output_token = sam_output_tokens[:, 0]\n        if multimask_output:\n            # take the best mask prediction (with the highest IoU estimation)\n            best_iou_inds = torch.argmax(ious, dim=-1)\n            batch_inds = torch.arange(B, device=device)\n            low_res_masks = low_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            high_res_masks = high_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            if sam_output_tokens.size(1) > 1:\n                sam_output_token = sam_output_tokens[batch_inds, best_iou_inds]\n        else:\n            low_res_masks, high_res_masks = low_res_multimasks, high_res_multimasks\n\n        # Extract object pointer from the SAM output token (with occlusion handling)\n        obj_ptr = self.obj_ptr_proj(sam_output_token)\n        if self.pred_obj_scores:\n            # Allow *soft* no obj ptr, unlike for masks\n            if self.soft_no_obj_ptr:\n                lambda_is_obj_appearing = object_score_logits.sigmoid()\n            else:\n                lambda_is_obj_appearing = is_obj_appearing.float()\n\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_multimasks,\n            high_res_multimasks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def _use_mask_as_output(self, backbone_features, high_res_features, mask_inputs):\n        """\n        Directly turn binary `mask_inputs` into a output mask logits without using SAM.\n        (same input and output shapes as in _forward_sam_heads above).\n        """\n        # Use -10/+10 as logits for neg/pos pixels (very close to 0/1 in prob after sigmoid).\n        out_scale, out_bias = 20.0, -10.0  # sigmoid(-10.0)=4.5398e-05\n        mask_inputs_float = mask_inputs.float()\n        high_res_masks = mask_inputs_float * out_scale + out_bias\n        low_res_masks = F.interpolate(\n            high_res_masks,\n            size=(high_res_masks.size(-2) // 4, high_res_masks.size(-1) // 4),\n            align_corners=False,\n            mode="bilinear",\n            antialias=True,  # use antialias for downsampling\n        )\n        # a dummy IoU prediction of all 1\'s under mask input\n        ious = mask_inputs.new_ones(mask_inputs.size(0), 1).float()\n        if not self.use_obj_ptrs_in_encoder:\n            # all zeros as a dummy object pointer (of shape [B, C])\n            obj_ptr = torch.zeros(\n                mask_inputs.size(0), self.hidden_dim, device=mask_inputs.device\n            )\n        else:\n            # produce an object pointer using the SAM decoder from the mask input\n            _, _, _, _, _, obj_ptr, _ = self._forward_sam_heads(\n                backbone_features=backbone_features,\n                mask_inputs=self.mask_downsample(mask_inputs_float),\n                high_res_features=high_res_features,\n            )\n        # In this method, we are treating mask_input as output, e.g. using it directly to create spatial mem;\n        # Below, we follow the same design axiom to use mask_input to decide if obj appears or not instead of relying\n        # on the object_scores from the SAM decoder.\n        is_obj_appearing = torch.any(mask_inputs.flatten(1).float() > 0.0, dim=1)\n        is_obj_appearing = is_obj_appearing[..., None]\n        lambda_is_obj_appearing = is_obj_appearing.float()\n        object_score_logits = out_scale * lambda_is_obj_appearing + out_bias\n        if self.pred_obj_scores:\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_masks,\n            high_res_masks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def forward_image(self, img_batch: torch.Tensor):\n        """Get the image feature on the input batch."""\n        backbone_out = self.image_encoder(img_batch)\n        if self.use_high_res_features_in_sam:\n            # precompute projected level 0 and level 1 features in SAM decoder\n            # to avoid running it again on every SAM click\n            backbone_out["backbone_fpn"][0] = self.sam_mask_decoder.conv_s0(\n                backbone_out["backbone_fpn"][0]\n            )\n            backbone_out["backbone_fpn"][1] = self.sam_mask_decoder.conv_s1(\n                backbone_out["backbone_fpn"][1]\n            )\n        return backbone_out\n\n    def _prepare_backbone_features(self, backbone_out):\n        """Prepare and flatten visual features."""\n        backbone_out = backbone_out.copy()\n        assert len(backbone_out["backbone_fpn"]) == len(backbone_out["vision_pos_enc"])\n        assert len(backbone_out["backbone_fpn"]) >= self.num_feature_levels\n\n        feature_maps = backbone_out["backbone_fpn"][-self.num_feature_levels :]\n        vision_pos_embeds = backbone_out["vision_pos_enc"][-self.num_feature_levels :]\n\n        feat_sizes = [(x.shape[-2], x.shape[-1]) for x in vision_pos_embeds]\n        # flatten NxCxHxW to HWxNxC\n        vision_feats = [x.flatten(2).permute(2, 0, 1) for x in feature_maps]\n        vision_pos_embeds = [x.flatten(2).permute(2, 0, 1) for x in vision_pos_embeds]\n\n        return backbone_out, vision_feats, vision_pos_embeds, feat_sizes\n\n    def _prepare_memory_conditioned_features(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n    ):\n        """Fuse the current frame\'s visual feature map with previous memory."""\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        device = current_vision_feats[-1].device\n        # The case of `self.num_maskmem == 0` below is primarily used for reproducing SAM on images.\n        # In this case, we skip the fusion with any memory.\n        if self.num_maskmem == 0:  # Disable memory and skip fusion\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n            return pix_feat\n\n        num_obj_ptr_tokens = 0\n        tpos_sign_mul = -1 if track_in_reverse else 1\n        # Step 1: condition the visual features of the current frame on previous memories\n        if not is_init_cond_frame:\n            # Retrieve the memories encoded with the maskmem backbone\n            to_cat_memory, to_cat_memory_pos_embed = [], []\n            # Add conditioning frames\'s output first (all cond frames have t_pos=0 for\n            # when getting temporal positional embedding below)\n            assert len(output_dict["cond_frame_outputs"]) > 0\n            # Select a maximum number of temporally closest cond frames for cross attention\n            cond_outputs = output_dict["cond_frame_outputs"]\n            selected_cond_outputs, unselected_cond_outputs = select_closest_cond_frames(\n                frame_idx, cond_outputs, self.max_cond_frames_in_attn\n            )\n            t_pos_and_prevs = [(0, out) for out in selected_cond_outputs.values()]\n            # Add last (self.num_maskmem - 1) frames before current frame for non-conditioning memory\n            # the earliest one has t_pos=1 and the latest one has t_pos=self.num_maskmem-1\n            # We also allow taking the memory frame non-consecutively (with stride>1), in which case\n            # we take (self.num_maskmem - 2) frames among every stride-th frames plus the last frame.\n            stride = 1 if self.training else self.memory_temporal_stride_for_eval\n            for t_pos in range(1, self.num_maskmem):\n                t_rel = self.num_maskmem - t_pos  # how many frames before current frame\n                if t_rel == 1:\n                    # for t_rel == 1, we take the last frame (regardless of r)\n                    if not track_in_reverse:\n                        # the frame immediately before this frame (i.e. frame_idx - 1)\n                        prev_frame_idx = frame_idx - t_rel\n                    else:\n                        # the frame immediately after this frame (i.e. frame_idx + 1)\n                        prev_frame_idx = frame_idx + t_rel\n                else:\n                    # for t_rel >= 2, we take the memory frame from every r-th frames\n                    if not track_in_reverse:\n                        # first find the nearest frame among every r-th frames before this frame\n                        # for r=1, this would be (frame_idx - 2)\n                        prev_frame_idx = ((frame_idx - 2) // stride) * stride\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx - (t_rel - 2) * stride\n                    else:\n                        # first find the nearest frame among every r-th frames after this frame\n                        # for r=1, this would be (frame_idx + 2)\n                        prev_frame_idx = -(-(frame_idx + 2) // stride) * stride\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx + (t_rel - 2) * stride\n                out = output_dict["non_cond_frame_outputs"].get(prev_frame_idx, None)\n                if out is None:\n                    # If an unselected conditioning frame is among the last (self.num_maskmem - 1)\n                    # frames, we still attend to it as if it\'s a non-conditioning frame.\n                    out = unselected_cond_outputs.get(prev_frame_idx, None)\n                t_pos_and_prevs.append((t_pos, out))\n\n            for t_pos, prev in t_pos_and_prevs:\n                if prev is None:\n                    continue  # skip padding frames\n                # "maskmem_features" might have been offloaded to CPU in demo use cases,\n                # so we load it back to GPU (it\'s a no-op if it\'s already on GPU).\n                feats = prev["maskmem_features"].to(device, non_blocking=True)\n                to_cat_memory.append(feats.flatten(2).permute(2, 0, 1))\n                # Spatial positional encoding (it might have been offloaded to CPU in eval)\n                maskmem_enc = prev["maskmem_pos_enc"][-1].to(device)\n                maskmem_enc = maskmem_enc.flatten(2).permute(2, 0, 1)\n                # Temporal positional encoding\n                maskmem_enc = (\n                    maskmem_enc + self.maskmem_tpos_enc[self.num_maskmem - t_pos - 1]\n                )\n                to_cat_memory_pos_embed.append(maskmem_enc)\n\n            # Construct the list of past object pointers\n            if self.use_obj_ptrs_in_encoder:\n                max_obj_ptrs_in_encoder = min(num_frames, self.max_obj_ptrs_in_encoder)\n                # First add those object pointers from selected conditioning frames\n                # (optionally, only include object pointers in the past during evaluation)\n                if not self.training and self.only_obj_ptrs_in_the_past_for_eval:\n                    ptr_cond_outputs = {\n                        t: out\n                        for t, out in selected_cond_outputs.items()\n                        if (t >= frame_idx if track_in_reverse else t <= frame_idx)\n                    }\n                else:\n                    ptr_cond_outputs = selected_cond_outputs\n                pos_and_ptrs = [\n                    # Temporal pos encoding contains how far away each pointer is from current frame\n                    (\n                        (\n                            (frame_idx - t) * tpos_sign_mul\n                            if self.use_signed_tpos_enc_to_obj_ptrs\n                            else abs(frame_idx - t)\n                        ),\n                        out["obj_ptr"],\n                    )\n                    for t, out in ptr_cond_outputs.items()\n                ]\n                # Add up to (max_obj_ptrs_in_encoder - 1) non-conditioning frames before current frame\n                for t_diff in range(1, max_obj_ptrs_in_encoder):\n                    t = frame_idx + t_diff if track_in_reverse else frame_idx - t_diff\n                    if t < 0 or (num_frames is not None and t >= num_frames):\n                        break\n                    out = output_dict["non_cond_frame_outputs"].get(\n                        t, unselected_cond_outputs.get(t, None)\n                    )\n                    if out is not None:\n                        pos_and_ptrs.append((t_diff, out["obj_ptr"]))\n                # If we have at least one object pointer, add them to the across attention\n                if len(pos_and_ptrs) > 0:\n                    pos_list, ptrs_list = zip(*pos_and_ptrs)\n                    # stack object pointers along dim=0 into [ptr_seq_len, B, C] shape\n                    obj_ptrs = torch.stack(ptrs_list, dim=0)\n                    # a temporal positional embedding based on how far each object pointer is from\n                    # the current frame (sine embedding normalized by the max pointer num).\n                    if self.add_tpos_enc_to_obj_ptrs:\n                        t_diff_max = max_obj_ptrs_in_encoder - 1\n                        tpos_dim = C if self.proj_tpos_enc_in_obj_ptrs else self.mem_dim\n                        obj_pos = torch.tensor(pos_list).to(\n                            device=device, non_blocking=True\n                        )\n                        obj_pos = get_1d_sine_pe(obj_pos / t_diff_max, dim=tpos_dim)\n                        obj_pos = self.obj_ptr_tpos_proj(obj_pos)\n                        obj_pos = obj_pos.unsqueeze(1).expand(-1, B, self.mem_dim)\n                    else:\n                        obj_pos = obj_ptrs.new_zeros(len(pos_list), B, self.mem_dim)\n                    if self.mem_dim < C:\n                        # split a pointer into (C // self.mem_dim) tokens for self.mem_dim < C\n                        obj_ptrs = obj_ptrs.reshape(\n                            -1, B, C // self.mem_dim, self.mem_dim\n                        )\n                        obj_ptrs = obj_ptrs.permute(0, 2, 1, 3).flatten(0, 1)\n                        obj_pos = obj_pos.repeat_interleave(C // self.mem_dim, dim=0)\n                    to_cat_memory.append(obj_ptrs)\n                    to_cat_memory_pos_embed.append(obj_pos)\n                    num_obj_ptr_tokens = obj_ptrs.shape[0]\n                else:\n                    num_obj_ptr_tokens = 0\n        else:\n            # for initial conditioning frames, encode them without using any previous memory\n            if self.directly_add_no_mem_embed:\n                # directly add no-mem embedding (instead of using the transformer encoder)\n                pix_feat_with_mem = current_vision_feats[-1] + self.no_mem_embed\n                pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n                return pix_feat_with_mem\n\n            # Use a dummy token on the first frame (to avoid empty memory input to tranformer encoder)\n            to_cat_memory = [self.no_mem_embed.expand(1, B, self.mem_dim)]\n            to_cat_memory_pos_embed = [self.no_mem_pos_enc.expand(1, B, self.mem_dim)]\n\n        # Step 2: Concatenate the memories and forward through the transformer encoder\n        memory = torch.cat(to_cat_memory, dim=0)\n        memory_pos_embed = torch.cat(to_cat_memory_pos_embed, dim=0)\n\n        pix_feat_with_mem = self.memory_attention(\n            curr=current_vision_feats,\n            curr_pos=current_vision_pos_embeds,\n            memory=memory,\n            memory_pos=memory_pos_embed,\n            num_obj_ptr_tokens=num_obj_ptr_tokens,\n        )\n        # reshape the output (HW)BC => BCHW\n        pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n        return pix_feat_with_mem\n\n    def _encode_new_memory(\n        self,\n        current_vision_feats,\n        feat_sizes,\n        pred_masks_high_res,\n        object_score_logits,\n        is_mask_from_pts,\n    ):\n        """Encode the current image and its prediction into a memory feature."""\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        # top-level feature, (HW)BC => BCHW\n        pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n        if self.non_overlap_masks_for_mem_enc and not self.training:\n            # optionally, apply non-overlapping constraints to the masks (it\'s applied\n            # in the batch dimension and should only be used during eval, where all\n            # the objects come from the same video under batch size 1).\n            pred_masks_high_res = self._apply_non_overlapping_constraints(\n                pred_masks_high_res\n            )\n        # scale the raw mask logits with a temperature before applying sigmoid\n        binarize = self.binarize_mask_from_pts_for_mem_enc and is_mask_from_pts\n        if binarize and not self.training:\n            mask_for_mem = (pred_masks_high_res > 0).float()\n        else:\n            # apply sigmoid on the raw mask logits to turn them into range (0, 1)\n            mask_for_mem = torch.sigmoid(pred_masks_high_res)\n        # apply scale and bias terms to the sigmoid probabilities\n        if self.sigmoid_scale_for_mem_enc != 1.0:\n            mask_for_mem = mask_for_mem * self.sigmoid_scale_for_mem_enc\n        if self.sigmoid_bias_for_mem_enc != 0.0:\n            mask_for_mem = mask_for_mem + self.sigmoid_bias_for_mem_enc\n        maskmem_out = self.memory_encoder(\n            pix_feat, mask_for_mem, skip_mask_sigmoid=True  # sigmoid already applied\n        )\n        maskmem_features = maskmem_out["vision_features"]\n        maskmem_pos_enc = maskmem_out["vision_pos_enc"]\n        # add a no-object embedding to the spatial memory to indicate that the frame\n        # is predicted to be occluded (i.e. no object is appearing in the frame)\n        if self.no_obj_embed_spatial is not None:\n            is_obj_appearing = (object_score_logits > 0).float()\n            maskmem_features += (\n                1 - is_obj_appearing[..., None, None]\n            ) * self.no_obj_embed_spatial[..., None, None].expand(\n                *maskmem_features.shape\n            )\n\n        return maskmem_features, maskmem_pos_enc\n\n    def _track_step(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        point_inputs,\n        mask_inputs,\n        output_dict,\n        num_frames,\n        track_in_reverse,\n        prev_sam_mask_logits,\n    ):\n        current_out = {"point_inputs": point_inputs, "mask_inputs": mask_inputs}\n        # High-resolution feature maps for the SAM head, reshape (HW)BC => BCHW\n        if len(current_vision_feats) > 1:\n            high_res_features = [\n                x.permute(1, 2, 0).view(x.size(1), x.size(2), *s)\n                for x, s in zip(current_vision_feats[:-1], feat_sizes[:-1])\n            ]\n        else:\n            high_res_features = None\n        if mask_inputs is not None and self.use_mask_input_as_output_without_sam:\n            # When use_mask_input_as_output_without_sam=True, we directly output the mask input\n            # (see it as a GT mask) without using a SAM prompt encoder + mask decoder.\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0)\n            pix_feat = pix_feat.view(-1, self.hidden_dim, *feat_sizes[-1])\n            sam_outputs = self._use_mask_as_output(\n                pix_feat, high_res_features, mask_inputs\n            )\n        else:\n            # fused the visual feature with previous memory features in the memory bank\n            pix_feat = self._prepare_memory_conditioned_features(\n                frame_idx=frame_idx,\n                is_init_cond_frame=is_init_cond_frame,\n                current_vision_feats=current_vision_feats[-1:],\n                current_vision_pos_embeds=current_vision_pos_embeds[-1:],\n                feat_sizes=feat_sizes[-1:],\n                output_dict=output_dict,\n                num_frames=num_frames,\n                track_in_reverse=track_in_reverse,\n            )\n            # apply SAM-style segmentation head\n            # here we might feed previously predicted low-res SAM mask logits into the SAM mask decoder,\n            # e.g. in demo where such logits come from earlier interaction instead of correction sampling\n            # (in this case, any `mask_inputs` shouldn\'t reach here as they are sent to _use_mask_as_output instead)\n            if prev_sam_mask_logits is not None:\n                assert point_inputs is not None and mask_inputs is None\n                mask_inputs = prev_sam_mask_logits\n            multimask_output = self._use_multimask(is_init_cond_frame, point_inputs)\n            sam_outputs = self._forward_sam_heads(\n                backbone_features=pix_feat,\n                point_inputs=point_inputs,\n                mask_inputs=mask_inputs,\n                high_res_features=high_res_features,\n                multimask_output=multimask_output,\n            )\n\n        return current_out, sam_outputs, high_res_features, pix_feat\n\n    def _encode_memory_in_output(\n        self,\n        current_vision_feats,\n        feat_sizes,\n        point_inputs,\n        run_mem_encoder,\n        high_res_masks,\n        object_score_logits,\n        current_out,\n    ):\n        if run_mem_encoder and self.num_maskmem > 0:\n            high_res_masks_for_mem_enc = high_res_masks\n            maskmem_features, maskmem_pos_enc = self._encode_new_memory(\n                current_vision_feats=current_vision_feats,\n                feat_sizes=feat_sizes,\n                pred_masks_high_res=high_res_masks_for_mem_enc,\n                object_score_logits=object_score_logits,\n                is_mask_from_pts=(point_inputs is not None),\n            )\n            current_out["maskmem_features"] = maskmem_features\n            current_out["maskmem_pos_enc"] = maskmem_pos_enc\n        else:\n            current_out["maskmem_features"] = None\n            current_out["maskmem_pos_enc"] = None\n\n    def track_step(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        point_inputs,\n        mask_inputs,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n        # Whether to run the memory encoder on the predicted masks. Sometimes we might want\n        # to skip the memory encoder with `run_mem_encoder=False`. For example,\n        # in demo we might call `track_step` multiple times for each user click,\n        # and only encode the memory when the user finalizes their clicks. And in ablation\n        # settings like SAM training on static images, we don\'t need the memory encoder.\n        run_mem_encoder=True,\n        # The previously predicted SAM mask logits (which can be fed together with new clicks in demo).\n        prev_sam_mask_logits=None,\n    ):\n        current_out, sam_outputs, _, _ = self._track_step(\n            frame_idx,\n            is_init_cond_frame,\n            current_vision_feats,\n            current_vision_pos_embeds,\n            feat_sizes,\n            point_inputs,\n            mask_inputs,\n            output_dict,\n            num_frames,\n            track_in_reverse,\n            prev_sam_mask_logits,\n        )\n\n        (\n            _,\n            _,\n            _,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        ) = sam_outputs\n\n        current_out["pred_masks"] = low_res_masks\n        current_out["pred_masks_high_res"] = high_res_masks\n        current_out["obj_ptr"] = obj_ptr\n        if not self.training:\n            # Only add this in inference (to avoid unused param in activation checkpointing;\n            # it\'s mainly used in the demo to encode spatial memories w/ consolidated masks)\n            current_out["object_score_logits"] = object_score_logits\n\n        # Finally run the memory encoder on the predicted mask to encode\n        # it into a new memory feature (that can be used in future frames)\n        self._encode_memory_in_output(\n            current_vision_feats,\n            feat_sizes,\n            point_inputs,\n            run_mem_encoder,\n            high_res_masks,\n            object_score_logits,\n            current_out,\n        )\n\n        return current_out\n\n    def _use_multimask(self, is_init_cond_frame, point_inputs):\n        """Whether to use multimask output in the SAM head."""\n        num_pts = 0 if point_inputs is None else point_inputs["point_labels"].size(1)\n        multimask_output = (\n            self.multimask_output_in_sam\n            and (is_init_cond_frame or self.multimask_output_for_tracking)\n            and (self.multimask_min_pt_num <= num_pts <= self.multimask_max_pt_num)\n        )\n        return multimask_output\n\n    def _apply_non_overlapping_constraints(self, pred_masks):\n        """\n        Apply non-overlapping constraints to the object scores in pred_masks. Here we\n        keep only the highest scoring object at each spatial location in pred_masks.\n        """\n        batch_size = pred_masks.size(0)\n        if batch_size == 1:\n            return pred_masks\n\n        device = pred_masks.device\n        # "max_obj_inds": object index of the object with the highest score at each location\n        max_obj_inds = torch.argmax(pred_masks, dim=0, keepdim=True)\n        # "batch_obj_inds": object index of each object slice (along dim 0) in `pred_masks`\n        batch_obj_inds = torch.arange(batch_size, device=device)[:, None, None, None]\n        keep = max_obj_inds == batch_obj_inds\n        # suppress overlapping regions\' scores below -10.0 so that the foreground regions\n        # don\'t overlap (here sigmoid(-10.0)=4.5398e-05)\n        pred_masks = torch.where(keep, pred_masks, torch.clamp(pred_masks, max=-10.0))\n        return pred_masks\n',
    'sam2.modeling.efficienttam_utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport copy\nfrom typing import Tuple, Union\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom sam2.utils.misc import mask_to_box\n\n\ndef select_closest_cond_frames(frame_idx, cond_frame_outputs, max_cond_frame_num):\n    """\n    Select up to `max_cond_frame_num` conditioning frames from `cond_frame_outputs`\n    that are temporally closest to the current frame at `frame_idx`. Here, we take\n    - a) the closest conditioning frame before `frame_idx` (if any);\n    - b) the closest conditioning frame after `frame_idx` (if any);\n    - c) any other temporally closest conditioning frames until reaching a total\n         of `max_cond_frame_num` conditioning frames.\n\n    Outputs:\n    - selected_outputs: selected items (keys & values) from `cond_frame_outputs`.\n    - unselected_outputs: items (keys & values) not selected in `cond_frame_outputs`.\n    """\n    if max_cond_frame_num == -1 or len(cond_frame_outputs) <= max_cond_frame_num:\n        selected_outputs = cond_frame_outputs\n        unselected_outputs = {}\n    else:\n        assert max_cond_frame_num >= 2, "we should allow using 2+ conditioning frames"\n        selected_outputs = {}\n\n        # the closest conditioning frame before `frame_idx` (if any)\n        idx_before = max((t for t in cond_frame_outputs if t < frame_idx), default=None)\n        if idx_before is not None:\n            selected_outputs[idx_before] = cond_frame_outputs[idx_before]\n\n        # the closest conditioning frame after `frame_idx` (if any)\n        idx_after = min((t for t in cond_frame_outputs if t >= frame_idx), default=None)\n        if idx_after is not None:\n            selected_outputs[idx_after] = cond_frame_outputs[idx_after]\n\n        # add other temporally closest conditioning frames until reaching a total\n        # of `max_cond_frame_num` conditioning frames.\n        num_remain = max_cond_frame_num - len(selected_outputs)\n        inds_remain = sorted(\n            (t for t in cond_frame_outputs if t not in selected_outputs),\n            key=lambda x: abs(x - frame_idx),\n        )[:num_remain]\n        selected_outputs.update((t, cond_frame_outputs[t]) for t in inds_remain)\n        unselected_outputs = {\n            t: v for t, v in cond_frame_outputs.items() if t not in selected_outputs\n        }\n\n    return selected_outputs, unselected_outputs\n\n\ndef get_1d_sine_pe(pos_inds, dim, temperature=10000):\n    """\n    Get 1D sine positional embedding as in the original Transformer paper.\n    """\n    pe_dim = dim // 2\n    dim_t = torch.arange(pe_dim, dtype=torch.float32, device=pos_inds.device)\n    dim_t = temperature ** (2 * (dim_t // 2) / pe_dim)\n\n    pos_embed = pos_inds.unsqueeze(-1) / dim_t\n    pos_embed = torch.cat([pos_embed.sin(), pos_embed.cos()], dim=-1)\n    return pos_embed\n\n\ndef get_activation_fn(activation):\n    """Return an activation function given a string"""\n    if activation == "relu":\n        return F.relu\n    if activation == "gelu":\n        return F.gelu\n    if activation == "glu":\n        return F.glu\n    raise RuntimeError(f"activation should be relu/gelu, not {activation}.")\n\n\ndef get_clones(module, N):\n    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])\n\n\nclass DropPath(nn.Module):\n    # adapted from https://github.com/huggingface/pytorch-image-models/blob/main/timm/layers/drop.py\n    def __init__(self, drop_prob=0.0, scale_by_keep=True):\n        super(DropPath, self).__init__()\n        self.drop_prob = drop_prob\n        self.scale_by_keep = scale_by_keep\n\n    def forward(self, x):\n        if self.drop_prob == 0.0 or not self.training:\n            return x\n        keep_prob = 1 - self.drop_prob\n        shape = (x.shape[0],) + (1,) * (x.ndim - 1)\n        random_tensor = x.new_empty(shape).bernoulli_(keep_prob)\n        if keep_prob > 0.0 and self.scale_by_keep:\n            random_tensor.div_(keep_prob)\n        return x * random_tensor\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        activation: nn.Module = nn.ReLU,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n        self.act = activation()\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = self.act(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x\n\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n\n\ndef sample_box_points(\n    masks: torch.Tensor,\n    noise: float = 0.1,  # SAM default\n    noise_bound: int = 10,  # SAM default\n    top_left_label: int = 2,\n    bottom_right_label: int = 3,\n) -> Tuple[np.array, np.array]:\n    """\n    Sample a noised version of the top left and bottom right corners of a given `bbox`\n\n    Inputs:\n    - masks: [B, 1, H,W] boxes, dtype=torch.Tensor\n    - noise: noise as a fraction of box width and height, dtype=float\n    - noise_bound: maximum amount of noise (in pure pixesl), dtype=int\n\n    Returns:\n    - box_coords: [B, num_pt, 2], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.float\n    - box_labels: [B, num_pt], label 2 is reserverd for top left and 3 for bottom right corners, dtype=torch.int32\n    """\n    device = masks.device\n    box_coords = mask_to_box(masks)\n    B, _, H, W = masks.shape\n    box_labels = torch.tensor(\n        [top_left_label, bottom_right_label], dtype=torch.int, device=device\n    ).repeat(B)\n    if noise > 0.0:\n        if not isinstance(noise_bound, torch.Tensor):\n            noise_bound = torch.tensor(noise_bound, device=device)\n        bbox_w = box_coords[..., 2] - box_coords[..., 0]\n        bbox_h = box_coords[..., 3] - box_coords[..., 1]\n        max_dx = torch.min(bbox_w * noise, noise_bound)\n        max_dy = torch.min(bbox_h * noise, noise_bound)\n        box_noise = 2 * torch.rand(B, 1, 4, device=device) - 1\n        box_noise = box_noise * torch.stack((max_dx, max_dy, max_dx, max_dy), dim=-1)\n\n        box_coords = box_coords + box_noise\n        img_bounds = (\n            torch.tensor([W, H, W, H], device=device) - 1\n        )  # uncentered pixel coords\n        box_coords.clamp_(torch.zeros_like(img_bounds), img_bounds)  # In place clamping\n\n    box_coords = box_coords.reshape(-1, 2, 2)  # always 2 points\n    box_labels = box_labels.reshape(-1, 2)\n    return box_coords, box_labels\n\n\ndef sample_random_points_from_errors(gt_masks, pred_masks, num_pt=1):\n    """\n    Sample `num_pt` random points (along with their labels) independently from the error regions.\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - num_pt: int, number of points to sample independently for each of the B error maps\n\n    Outputs:\n    - points: [B, num_pt, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, num_pt], dtype=torch.int32, where 1 means positive clicks and 0 means\n      negative clicks\n    """\n    if pred_masks is None:  # if pred_masks is not provided, treat it as empty\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n    assert num_pt >= 0\n\n    B, _, H_im, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n    # whether the prediction completely match the ground-truth on each mask\n    all_correct = torch.all((gt_masks == pred_masks).flatten(2), dim=2)\n    all_correct = all_correct[..., None, None]\n\n    # channel 0 is FP map, while channel 1 is FN map\n    pts_noise = torch.rand(B, num_pt, H_im, W_im, 2, device=device)\n    # sample a negative new click from FP region or a positive new click\n    # from FN region, depend on where the maximum falls,\n    # and in case the predictions are all correct (no FP or FN), we just\n    # sample a negative click from the background region\n    pts_noise[..., 0] *= fp_masks | (all_correct & ~gt_masks)\n    pts_noise[..., 1] *= fn_masks\n    pts_idx = pts_noise.flatten(2).argmax(dim=2)\n    labels = (pts_idx % 2).to(torch.int32)\n    pts_idx = pts_idx // 2\n    pts_x = pts_idx % W_im\n    pts_y = pts_idx // W_im\n    points = torch.stack([pts_x, pts_y], dim=2).to(torch.float)\n    return points, labels\n\n\ndef sample_one_point_from_error_center(gt_masks, pred_masks, padding=True):\n    """\n    Sample 1 random point (along with its label) from the center of each error region,\n    that is, the point with the largest distance to the boundary of each error region.\n    This is the RITM sampling method from https://github.com/saic-vul/ritm_interactive_segmentation/blob/master/isegm/inference/clicker.py\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - padding: if True, pad with boundary of 1 px for distance transform\n\n    Outputs:\n    - points: [B, 1, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, 1], dtype=torch.int32, where 1 means positive clicks and 0 means negative clicks\n    """\n    import cv2\n\n    if pred_masks is None:\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n\n    B, _, _, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n\n    fp_masks = fp_masks.cpu().numpy()\n    fn_masks = fn_masks.cpu().numpy()\n    points = torch.zeros(B, 1, 2, dtype=torch.float)\n    labels = torch.ones(B, 1, dtype=torch.int32)\n    for b in range(B):\n        fn_mask = fn_masks[b, 0]\n        fp_mask = fp_masks[b, 0]\n        if padding:\n            fn_mask = np.pad(fn_mask, ((1, 1), (1, 1)), "constant")\n            fp_mask = np.pad(fp_mask, ((1, 1), (1, 1)), "constant")\n        # compute the distance of each point in FN/FP region to its boundary\n        fn_mask_dt = cv2.distanceTransform(fn_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        fp_mask_dt = cv2.distanceTransform(fp_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        if padding:\n            fn_mask_dt = fn_mask_dt[1:-1, 1:-1]\n            fp_mask_dt = fp_mask_dt[1:-1, 1:-1]\n\n        # take the point in FN/FP region with the largest distance to its boundary\n        fn_mask_dt_flat = fn_mask_dt.reshape(-1)\n        fp_mask_dt_flat = fp_mask_dt.reshape(-1)\n        fn_argmax = np.argmax(fn_mask_dt_flat)\n        fp_argmax = np.argmax(fp_mask_dt_flat)\n        is_positive = fn_mask_dt_flat[fn_argmax] > fp_mask_dt_flat[fp_argmax]\n        pt_idx = fn_argmax if is_positive else fp_argmax\n        points[b, 0, 0] = pt_idx % W_im  # x\n        points[b, 0, 1] = pt_idx // W_im  # y\n        labels[b, 0] = int(is_positive)\n\n    points = points.to(device)\n    labels = labels.to(device)\n    return points, labels\n\n\ndef get_next_point(gt_masks, pred_masks, method):\n    if method == "uniform":\n        return sample_random_points_from_errors(gt_masks, pred_masks)\n    elif method == "center":\n        return sample_one_point_from_error_center(gt_masks, pred_masks)\n    else:\n        raise ValueError(f"unknown sampling method {method}")\n\n\nclass LayerScale(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        init_values: Union[float, torch.Tensor] = 1e-5,\n        inplace: bool = False,\n    ) -> None:\n        super().__init__()\n        self.inplace = inplace\n        self.gamma = nn.Parameter(init_values * torch.ones(dim))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return x.mul_(self.gamma) if self.inplace else x * self.gamma\n',
    'sam2.modeling.memory_attention': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional\n\nimport torch\nfrom torch import nn, Tensor\n\nfrom sam2.modeling.sam.transformer import RoPEAttention\n\nfrom sam2.modeling.sam2_utils import get_activation_fn, get_clones\n\n\nclass MemoryAttentionLayer(nn.Module):\n\n    def __init__(\n        self,\n        activation: str,\n        cross_attention: nn.Module,\n        d_model: int,\n        dim_feedforward: int,\n        dropout: float,\n        pos_enc_at_attn: bool,\n        pos_enc_at_cross_attn_keys: bool,\n        pos_enc_at_cross_attn_queries: bool,\n        self_attention: nn.Module,\n    ):\n        super().__init__()\n        self.d_model = d_model\n        self.dim_feedforward = dim_feedforward\n        self.dropout_value = dropout\n        self.self_attn = self_attention\n        self.cross_attn_image = cross_attention\n\n        # Implementation of Feedforward model\n        self.linear1 = nn.Linear(d_model, dim_feedforward)\n        self.dropout = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(dim_feedforward, d_model)\n\n        self.norm1 = nn.LayerNorm(d_model)\n        self.norm2 = nn.LayerNorm(d_model)\n        self.norm3 = nn.LayerNorm(d_model)\n        self.dropout1 = nn.Dropout(dropout)\n        self.dropout2 = nn.Dropout(dropout)\n        self.dropout3 = nn.Dropout(dropout)\n\n        self.activation_str = activation\n        self.activation = get_activation_fn(activation)\n\n        # Where to add pos enc\n        self.pos_enc_at_attn = pos_enc_at_attn\n        self.pos_enc_at_cross_attn_queries = pos_enc_at_cross_attn_queries\n        self.pos_enc_at_cross_attn_keys = pos_enc_at_cross_attn_keys\n\n    def _forward_sa(self, tgt, query_pos):\n        # Self-Attention\n        tgt2 = self.norm1(tgt)\n        q = k = tgt2 + query_pos if self.pos_enc_at_attn else tgt2\n        tgt2 = self.self_attn(q, k, v=tgt2)\n        tgt = tgt + self.dropout1(tgt2)\n        return tgt\n\n    def _forward_ca(self, tgt, memory, query_pos, pos, num_k_exclude_rope=0):\n        kwds = {}\n        if num_k_exclude_rope > 0:\n            assert isinstance(self.cross_attn_image, RoPEAttention)\n            kwds = {"num_k_exclude_rope": num_k_exclude_rope}\n\n        # Cross-Attention\n        tgt2 = self.norm2(tgt)\n        tgt2 = self.cross_attn_image(\n            q=tgt2 + query_pos if self.pos_enc_at_cross_attn_queries else tgt2,\n            k=memory + pos if self.pos_enc_at_cross_attn_keys else memory,\n            v=memory,\n            **kwds,\n        )\n        tgt = tgt + self.dropout2(tgt2)\n        return tgt\n\n    def forward(\n        self,\n        tgt,\n        memory,\n        pos: Optional[Tensor] = None,\n        query_pos: Optional[Tensor] = None,\n        num_k_exclude_rope: int = 0,\n    ) -> torch.Tensor:\n\n        # Self-Attn, Cross-Attn\n        tgt = self._forward_sa(tgt, query_pos)\n        tgt = self._forward_ca(tgt, memory, query_pos, pos, num_k_exclude_rope)\n        # MLP\n        tgt2 = self.norm3(tgt)\n        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt2))))\n        tgt = tgt + self.dropout3(tgt2)\n        return tgt\n\n\nclass MemoryAttention(nn.Module):\n    def __init__(\n        self,\n        d_model: int,\n        pos_enc_at_input: bool,\n        layer: nn.Module,\n        num_layers: int,\n        batch_first: bool = True,  # Do layers expect batch first input?\n    ):\n        super().__init__()\n        self.d_model = d_model\n        self.layers = get_clones(layer, num_layers)\n        self.num_layers = num_layers\n        self.norm = nn.LayerNorm(d_model)\n        self.pos_enc_at_input = pos_enc_at_input\n        self.batch_first = batch_first\n\n    def forward(\n        self,\n        curr: torch.Tensor,  # self-attention inputs\n        memory: torch.Tensor,  # cross-attention inputs\n        curr_pos: Optional[Tensor] = None,  # pos_enc for self-attention inputs\n        memory_pos: Optional[Tensor] = None,  # pos_enc for cross-attention inputs\n        num_obj_ptr_tokens: int = 0,  # number of object pointer *tokens*\n    ):\n        if isinstance(curr, list):\n            assert isinstance(curr_pos, list)\n            assert len(curr) == len(curr_pos) == 1\n            curr, curr_pos = (\n                curr[0],\n                curr_pos[0],\n            )\n\n        assert (\n            curr.shape[1] == memory.shape[1]\n        ), "Batch size must be the same for curr and memory"\n\n        output = curr\n        if self.pos_enc_at_input and curr_pos is not None:\n            output = output + 0.1 * curr_pos\n\n        if self.batch_first:\n            # Convert to batch first\n            output = output.transpose(0, 1)\n            curr_pos = curr_pos.transpose(0, 1)\n            memory = memory.transpose(0, 1)\n            memory_pos = memory_pos.transpose(0, 1)\n\n        for layer in self.layers:\n            kwds = {}\n            if isinstance(layer.cross_attn_image, RoPEAttention):\n                kwds = {"num_k_exclude_rope": num_obj_ptr_tokens}\n\n            output = layer(\n                tgt=output,\n                memory=memory,\n                pos=memory_pos,\n                query_pos=curr_pos,\n                **kwds,\n            )\n        normed_output = self.norm(output)\n\n        if self.batch_first:\n            # Convert back to seq first\n            normed_output = normed_output.transpose(0, 1)\n            curr_pos = curr_pos.transpose(0, 1)\n\n        return normed_output\n',
    'sam2.modeling.memory_encoder': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom sam2.modeling.sam2_utils import DropPath, get_clones, LayerNorm2d\n\n\nclass MaskDownSampler(nn.Module):\n    """\n    Progressively downsample a mask by total_stride, each time by stride.\n    Note that LayerNorm is applied per *token*, like in ViT.\n\n    With each downsample (by a factor stride**2), channel capacity increases by the same factor.\n    In the end, we linearly project to embed_dim channels.\n    """\n\n    def __init__(\n        self,\n        embed_dim=256,\n        kernel_size=4,\n        stride=4,\n        padding=0,\n        total_stride=16,\n        activation=nn.GELU,\n    ):\n        super().__init__()\n        num_layers = int(math.log2(total_stride) // math.log2(stride))\n        assert stride**num_layers == total_stride\n        self.encoder = nn.Sequential()\n        mask_in_chans, mask_out_chans = 1, 1\n        for _ in range(num_layers):\n            mask_out_chans = mask_in_chans * (stride**2)\n            self.encoder.append(\n                nn.Conv2d(\n                    mask_in_chans,\n                    mask_out_chans,\n                    kernel_size=kernel_size,\n                    stride=stride,\n                    padding=padding,\n                )\n            )\n            self.encoder.append(LayerNorm2d(mask_out_chans))\n            self.encoder.append(activation())\n            mask_in_chans = mask_out_chans\n\n        self.encoder.append(nn.Conv2d(mask_out_chans, embed_dim, kernel_size=1))\n\n    def forward(self, x):\n        return self.encoder(x)\n\n\n# Lightly adapted from ConvNext (https://github.com/facebookresearch/ConvNeXt)\nclass CXBlock(nn.Module):\n    r"""ConvNeXt Block. There are two equivalent implementations:\n    (1) DwConv -> LayerNorm (channels_first) -> 1x1 Conv -> GELU -> 1x1 Conv; all in (N, C, H, W)\n    (2) DwConv -> Permute to (N, H, W, C); LayerNorm (channels_last) -> Linear -> GELU -> Linear; Permute back\n    We use (2) as we find it slightly faster in PyTorch\n\n    Args:\n        dim (int): Number of input channels.\n        drop_path (float): Stochastic depth rate. Default: 0.0\n        layer_scale_init_value (float): Init value for Layer Scale. Default: 1e-6.\n    """\n\n    def __init__(\n        self,\n        dim,\n        kernel_size=7,\n        padding=3,\n        drop_path=0.0,\n        layer_scale_init_value=1e-6,\n        use_dwconv=True,\n    ):\n        super().__init__()\n        self.dwconv = nn.Conv2d(\n            dim,\n            dim,\n            kernel_size=kernel_size,\n            padding=padding,\n            groups=dim if use_dwconv else 1,\n        )  # depthwise conv\n        self.norm = LayerNorm2d(dim, eps=1e-6)\n        self.pwconv1 = nn.Linear(\n            dim, 4 * dim\n        )  # pointwise/1x1 convs, implemented with linear layers\n        self.act = nn.GELU()\n        self.pwconv2 = nn.Linear(4 * dim, dim)\n        self.gamma = (\n            nn.Parameter(layer_scale_init_value * torch.ones((dim)), requires_grad=True)\n            if layer_scale_init_value > 0\n            else None\n        )\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n\n    def forward(self, x):\n        input = x\n        x = self.dwconv(x)\n        x = self.norm(x)\n        x = x.permute(0, 2, 3, 1)  # (N, C, H, W) -> (N, H, W, C)\n        x = self.pwconv1(x)\n        x = self.act(x)\n        x = self.pwconv2(x)\n        if self.gamma is not None:\n            x = self.gamma * x\n        x = x.permute(0, 3, 1, 2)  # (N, H, W, C) -> (N, C, H, W)\n\n        x = input + self.drop_path(x)\n        return x\n\n\nclass Fuser(nn.Module):\n    def __init__(self, layer, num_layers, dim=None, input_projection=False):\n        super().__init__()\n        self.proj = nn.Identity()\n        self.layers = get_clones(layer, num_layers)\n\n        if input_projection:\n            assert dim is not None\n            self.proj = nn.Conv2d(dim, dim, kernel_size=1)\n\n    def forward(self, x):\n        # normally x: (N, C, H, W)\n        x = self.proj(x)\n        for layer in self.layers:\n            x = layer(x)\n        return x\n\n\nclass MemoryEncoder(nn.Module):\n    def __init__(\n        self,\n        out_dim,\n        mask_downsampler,\n        fuser,\n        position_encoding,\n        in_dim=256,  # in_dim of pix_feats\n    ):\n        super().__init__()\n\n        self.mask_downsampler = mask_downsampler\n\n        self.pix_feat_proj = nn.Conv2d(in_dim, in_dim, kernel_size=1)\n        self.fuser = fuser\n        self.position_encoding = position_encoding\n        self.out_proj = nn.Identity()\n        if out_dim != in_dim:\n            self.out_proj = nn.Conv2d(in_dim, out_dim, kernel_size=1)\n\n    def forward(\n        self,\n        pix_feat: torch.Tensor,\n        masks: torch.Tensor,\n        skip_mask_sigmoid: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        ## Process masks\n        # sigmoid, so that less domain shift from gt masks which are bool\n        if not skip_mask_sigmoid:\n            masks = F.sigmoid(masks)\n        masks = self.mask_downsampler(masks)\n\n        ## Fuse pix_feats and downsampled masks\n        # in case the visual features are on CPU, cast them to CUDA\n        pix_feat = pix_feat.to(masks.device)\n\n        x = self.pix_feat_proj(pix_feat)\n        x = x + masks\n        x = self.fuser(x)\n        x = self.out_proj(x)\n\n        pos = self.position_encoding(x).to(x.dtype)\n\n        return {"vision_features": x, "vision_pos_enc": [pos]}\n',
    'sam2.modeling.position_encoding': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Any, Optional, Tuple\n\nimport numpy as np\n\nimport torch\nfrom torch import nn\n\n\nclass PositionEmbeddingSine(nn.Module):\n    """\n    This is a more standard version of the position embedding, very similar to the one\n    used by the Attention Is All You Need paper, generalized to work on images.\n    """\n\n    def __init__(\n        self,\n        num_pos_feats,\n        temperature: int = 10000,\n        normalize: bool = True,\n        scale: Optional[float] = None,\n    ):\n        super().__init__()\n        assert num_pos_feats % 2 == 0, "Expecting even model width"\n        self.num_pos_feats = num_pos_feats // 2\n        self.temperature = temperature\n        self.normalize = normalize\n        if scale is not None and normalize is False:\n            raise ValueError("normalize should be True if scale is passed")\n        if scale is None:\n            scale = 2 * math.pi\n        self.scale = scale\n\n        self.cache = {}\n\n    def _encode_xy(self, x, y):\n        # The positions are expected to be normalized\n        assert len(x) == len(y) and x.ndim == y.ndim == 1\n        x_embed = x * self.scale\n        y_embed = y * self.scale\n\n        dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)\n\n        pos_x = x_embed[:, None] / dim_t\n        pos_y = y_embed[:, None] / dim_t\n        pos_x = torch.stack(\n            (pos_x[:, 0::2].sin(), pos_x[:, 1::2].cos()), dim=2\n        ).flatten(1)\n        pos_y = torch.stack(\n            (pos_y[:, 0::2].sin(), pos_y[:, 1::2].cos()), dim=2\n        ).flatten(1)\n        return pos_x, pos_y\n\n    @torch.no_grad()\n    def encode_boxes(self, x, y, w, h):\n        pos_x, pos_y = self._encode_xy(x, y)\n        pos = torch.cat((pos_y, pos_x, h[:, None], w[:, None]), dim=1)\n        return pos\n\n    encode = encode_boxes  # Backwards compatibility\n\n    @torch.no_grad()\n    def encode_points(self, x, y, labels):\n        (bx, nx), (by, ny), (bl, nl) = x.shape, y.shape, labels.shape\n        assert bx == by and nx == ny and bx == bl and nx == nl\n        pos_x, pos_y = self._encode_xy(x.flatten(), y.flatten())\n        pos_x, pos_y = pos_x.reshape(bx, nx, -1), pos_y.reshape(by, ny, -1)\n        pos = torch.cat((pos_y, pos_x, labels[:, :, None]), dim=2)\n        return pos\n\n    @torch.no_grad()\n    def forward(self, x: torch.Tensor):\n        cache_key = (x.shape[-2], x.shape[-1])\n        if cache_key in self.cache:\n            return self.cache[cache_key][None].repeat(x.shape[0], 1, 1, 1)\n        y_embed = (\n            torch.arange(1, x.shape[-2] + 1, dtype=torch.float32, device=x.device)\n            .view(1, -1, 1)\n            .repeat(x.shape[0], 1, x.shape[-1])\n        )\n        x_embed = (\n            torch.arange(1, x.shape[-1] + 1, dtype=torch.float32, device=x.device)\n            .view(1, 1, -1)\n            .repeat(x.shape[0], x.shape[-2], 1)\n        )\n\n        if self.normalize:\n            eps = 1e-6\n            y_embed = y_embed / (y_embed[:, -1:, :] + eps) * self.scale\n            x_embed = x_embed / (x_embed[:, :, -1:] + eps) * self.scale\n\n        dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)\n\n        pos_x = x_embed[:, :, :, None] / dim_t\n        pos_y = y_embed[:, :, :, None] / dim_t\n        pos_x = torch.stack(\n            (pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos_y = torch.stack(\n            (pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)\n        self.cache[cache_key] = pos[0]\n        return pos\n\n\nclass PositionEmbeddingRandom(nn.Module):\n    """\n    Positional encoding using random spatial frequencies.\n    """\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\n            "positional_encoding_gaussian_matrix",\n            scale * torch.randn((2, num_pos_feats)),\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        """Positionally encode points that are normalized to [0,1]."""\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        """Generate positional encoding for a grid of the specified size."""\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones((h, w), device=device, dtype=torch.float32)\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        """Positionally encode points that are not normalized to [0,1]."""\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C\n\n\n# Rotary Positional Encoding, adapted from:\n# 1. https://github.com/meta-llama/codellama/blob/main/llama/model.py\n# 2. https://github.com/naver-ai/rope-vit\n# 3. https://github.com/lucidrains/rotary-embedding-torch\n\n\ndef init_t_xy(end_x: int, end_y: int):\n    t = torch.arange(end_x * end_y, dtype=torch.float32)\n    t_x = (t % end_x).float()\n    t_y = torch.div(t, end_x, rounding_mode="floor").float()\n    return t_x, t_y\n\n\ndef compute_axial_cis(dim: int, end_x: int, end_y: int, theta: float = 10000.0):\n    freqs_x = 1.0 / (theta ** (torch.arange(0, dim, 4)[: (dim // 4)].float() / dim))\n    freqs_y = 1.0 / (theta ** (torch.arange(0, dim, 4)[: (dim // 4)].float() / dim))\n\n    t_x, t_y = init_t_xy(end_x, end_y)\n    freqs_x = torch.outer(t_x, freqs_x)\n    freqs_y = torch.outer(t_y, freqs_y)\n    freqs_cis_x = torch.polar(torch.ones_like(freqs_x), freqs_x)\n    freqs_cis_y = torch.polar(torch.ones_like(freqs_y), freqs_y)\n    return torch.cat([freqs_cis_x, freqs_cis_y], dim=-1)\n\n\ndef reshape_for_broadcast(freqs_cis: torch.Tensor, x: torch.Tensor):\n    ndim = x.ndim\n    assert 0 <= 1 < ndim\n    assert freqs_cis.shape == (x.shape[-2], x.shape[-1])\n    shape = [d if i >= ndim - 2 else 1 for i, d in enumerate(x.shape)]\n    return freqs_cis.view(*shape)\n\n\ndef apply_rotary_enc(\n    xq: torch.Tensor,\n    xk: torch.Tensor,\n    freqs_cis: torch.Tensor,\n    repeat_freqs_k: bool = False,\n):\n    xq_ = torch.view_as_complex(xq.float().reshape(*xq.shape[:-1], -1, 2))\n    xk_ = (\n        torch.view_as_complex(xk.float().reshape(*xk.shape[:-1], -1, 2))\n        if xk.shape[-2] != 0\n        else None\n    )\n    freqs_cis = reshape_for_broadcast(freqs_cis, xq_)\n    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(3)\n    if xk_ is None:\n        # no keys to rotate, due to dropout\n        return xq_out.type_as(xq).to(xq.device), xk\n    # repeat freqs along seq_len dim to match k seq_len\n    if repeat_freqs_k:\n        r = xk_.shape[-2] // xq_.shape[-2]\n        if freqs_cis.is_cuda:\n            freqs_cis = freqs_cis.repeat(*([1] * (freqs_cis.ndim - 2)), r, 1)\n        else:\n            # torch.repeat on complex numbers may not be supported on non-CUDA devices\n            # (freqs_cis has 4 dims and we repeat on dim 2) so we use expand + flatten\n            freqs_cis = freqs_cis.unsqueeze(2).expand(-1, -1, r, -1, -1).flatten(2, 3)\n    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(3)\n    return xq_out.type_as(xq).to(xq.device), xk_out.type_as(xk).to(xk.device)\n',
    'sam2.modeling.sam': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'sam2.modeling.sam.mask_decoder': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Optional, Tuple, Type\n\nimport torch\nfrom torch import nn\n\nfrom sam2.modeling.sam2_utils import LayerNorm2d, MLP\n\n\nclass MaskDecoder(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n        use_high_res_features: bool = False,\n        iou_prediction_use_sigmoid=False,\n        dynamic_multimask_via_stability=False,\n        dynamic_multimask_stability_delta=0.05,\n        dynamic_multimask_stability_thresh=0.98,\n        pred_obj_scores: bool = False,\n        pred_obj_scores_mlp: bool = False,\n        use_multimask_token_for_obj_ptr: bool = False,\n    ) -> None:\n        """\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        """\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.pred_obj_scores = pred_obj_scores\n        if self.pred_obj_scores:\n            self.obj_score_token = nn.Embedding(1, transformer_dim)\n        self.use_multimask_token_for_obj_ptr = use_multimask_token_for_obj_ptr\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(\n                transformer_dim, transformer_dim // 4, kernel_size=2, stride=2\n            ),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(\n                transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2\n            ),\n            activation(),\n        )\n        self.use_high_res_features = use_high_res_features\n        if use_high_res_features:\n            self.conv_s0 = nn.Conv2d(\n                transformer_dim, transformer_dim // 8, kernel_size=1, stride=1\n            )\n            self.conv_s1 = nn.Conv2d(\n                transformer_dim, transformer_dim // 4, kernel_size=1, stride=1\n            )\n\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim,\n            iou_head_hidden_dim,\n            self.num_mask_tokens,\n            iou_head_depth,\n            sigmoid_output=iou_prediction_use_sigmoid,\n        )\n        if self.pred_obj_scores:\n            self.pred_obj_score_head = nn.Linear(transformer_dim, 1)\n            if pred_obj_scores_mlp:\n                self.pred_obj_score_head = MLP(transformer_dim, transformer_dim, 1, 3)\n\n        # When outputting a single mask, optionally we can dynamically fall back to the best\n        # multimask output token if the single mask output token gives low stability scores.\n        self.dynamic_multimask_via_stability = dynamic_multimask_via_stability\n        self.dynamic_multimask_stability_delta = dynamic_multimask_stability_delta\n        self.dynamic_multimask_stability_thresh = dynamic_multimask_stability_thresh\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n        repeat_image: bool,\n        high_res_features: Optional[List[torch.Tensor]] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        """\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the image encoder\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n          torch.Tensor: batched SAM token for mask output\n        """\n        masks, iou_pred, mask_tokens_out, object_score_logits = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n            repeat_image=repeat_image,\n            high_res_features=high_res_features,\n        )\n\n        # Select the correct mask or masks for output\n        if multimask_output:\n            masks = masks[:, 1:, :, :]\n            iou_pred = iou_pred[:, 1:]\n        elif self.dynamic_multimask_via_stability and not self.training:\n            masks, iou_pred = self._dynamic_multimask_via_stability(masks, iou_pred)\n        else:\n            masks = masks[:, 0:1, :, :]\n            iou_pred = iou_pred[:, 0:1]\n\n        if multimask_output and self.use_multimask_token_for_obj_ptr:\n            sam_tokens_out = mask_tokens_out[:, 1:]  # [b, 3, c] shape\n        else:\n            # Take the mask output token. Here we *always* use the token for single mask output.\n            # At test time, even if we track after 1-click (and using multimask_output=True),\n            # we still take the single mask token here. The rationale is that we always track\n            # after multiple clicks during training, so the past tokens seen during training\n            # are always the single mask token (and we\'ll let it be the object-memory token).\n            sam_tokens_out = mask_tokens_out[:, 0:1]  # [b, 1, c] shape\n\n        # Prepare output\n        return masks, iou_pred, sam_tokens_out, object_score_logits\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        repeat_image: bool,\n        high_res_features: Optional[List[torch.Tensor]] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        """Predicts masks. See \'forward\' for more details."""\n        # Concatenate output tokens\n        s = 0\n        if self.pred_obj_scores:\n            output_tokens = torch.cat(\n                [\n                    self.obj_score_token.weight,\n                    self.iou_token.weight,\n                    self.mask_tokens.weight,\n                ],\n                dim=0,\n            )\n            s = 1\n        else:\n            output_tokens = torch.cat(\n                [self.iou_token.weight, self.mask_tokens.weight], dim=0\n            )\n        output_tokens = output_tokens.unsqueeze(0).expand(\n            sparse_prompt_embeddings.size(0), -1, -1\n        )\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        if repeat_image:\n            src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        else:\n            assert image_embeddings.shape[0] == tokens.shape[0]\n            src = image_embeddings\n        src = src + dense_prompt_embeddings\n        assert (\n            image_pe.size(0) == 1\n        ), "image_pe should have size 1 in batch dim (from `get_dense_pe()`)"\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, s, :]\n        mask_tokens_out = hs[:, s + 1 : (s + 1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n        if not self.use_high_res_features:\n            upscaled_embedding = self.output_upscaling(src)\n        else:\n            dc1, ln1, act1, dc2, act2 = self.output_upscaling\n            feat_s0, feat_s1 = high_res_features\n            upscaled_embedding = act1(ln1(dc1(src) + feat_s1))\n            upscaled_embedding = act2(dc2(upscaled_embedding) + feat_s0)\n\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            hyper_in_list.append(\n                self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :])\n            )\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n        if self.pred_obj_scores:\n            assert s == 1\n            object_score_logits = self.pred_obj_score_head(hs[:, 0, :])\n        else:\n            # Obj scores logits - default to 10.0, i.e. assuming the object is present, sigmoid(10)=1\n            object_score_logits = 10.0 * iou_pred.new_ones(iou_pred.shape[0], 1)\n\n        return masks, iou_pred, mask_tokens_out, object_score_logits\n\n    def _get_stability_scores(self, mask_logits):\n        """\n        Compute stability scores of the mask logits based on the IoU between upper and\n        lower thresholds.\n        """\n        mask_logits = mask_logits.flatten(-2)\n        stability_delta = self.dynamic_multimask_stability_delta\n        area_i = torch.sum(mask_logits > stability_delta, dim=-1).float()\n        area_u = torch.sum(mask_logits > -stability_delta, dim=-1).float()\n        stability_scores = torch.where(area_u > 0, area_i / area_u, 1.0)\n        return stability_scores\n\n    def _dynamic_multimask_via_stability(self, all_mask_logits, all_iou_scores):\n        """\n        When outputting a single mask, if the stability score from the current single-mask\n        output (based on output token 0) falls below a threshold, we instead select from\n        multi-mask outputs (based on output token 1~3) the mask with the highest predicted\n        IoU score. This is intended to ensure a valid mask for both clicking and tracking.\n        """\n        # The best mask from multimask output tokens (1~3)\n        multimask_logits = all_mask_logits[:, 1:, :, :]\n        multimask_iou_scores = all_iou_scores[:, 1:]\n        best_scores_inds = torch.argmax(multimask_iou_scores, dim=-1)\n        batch_inds = torch.arange(\n            multimask_iou_scores.size(0), device=all_iou_scores.device\n        )\n        best_multimask_logits = multimask_logits[batch_inds, best_scores_inds]\n        best_multimask_logits = best_multimask_logits.unsqueeze(1)\n        best_multimask_iou_scores = multimask_iou_scores[batch_inds, best_scores_inds]\n        best_multimask_iou_scores = best_multimask_iou_scores.unsqueeze(1)\n\n        # The mask from singlemask output token 0 and its stability score\n        singlemask_logits = all_mask_logits[:, 0:1, :, :]\n        singlemask_iou_scores = all_iou_scores[:, 0:1]\n        stability_scores = self._get_stability_scores(singlemask_logits)\n        is_stable = stability_scores >= self.dynamic_multimask_stability_thresh\n\n        # Dynamically fall back to best multimask output upon low stability scores.\n        mask_logits_out = torch.where(\n            is_stable[..., None, None].expand_as(singlemask_logits),\n            singlemask_logits,\n            best_multimask_logits,\n        )\n        iou_scores_out = torch.where(\n            is_stable.expand_as(singlemask_iou_scores),\n            singlemask_iou_scores,\n            best_multimask_iou_scores,\n        )\n        return mask_logits_out, iou_scores_out\n',
    'sam2.modeling.sam.prompt_encoder': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional, Tuple, Type\n\nimport torch\nfrom torch import nn\n\nfrom sam2.modeling.position_encoding import PositionEmbeddingRandom\n\nfrom sam2.modeling.sam2_utils import LayerNorm2d\n\n\nclass PromptEncoder(nn.Module):\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n        mask_in_chans: int,\n        activation: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        """\n        Encodes prompts for input to SAM\'s mask decoder.\n\n        Arguments:\n          embed_dim (int): The prompts\' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n          mask_in_chans (int): The number of hidden channels used for\n            encoding input masks.\n          activation (nn.Module): The activation to use when encoding\n            input masks.\n        """\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n        self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n        point_embeddings = [\n            nn.Embedding(1, embed_dim) for i in range(self.num_point_embeddings)\n        ]\n        self.point_embeddings = nn.ModuleList(point_embeddings)\n        self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n        self.mask_input_size = (\n            4 * image_embedding_size[0],\n            4 * image_embedding_size[1],\n        )\n        self.mask_downscaling = nn.Sequential(\n            nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans // 4),\n            activation(),\n            nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans),\n            activation(),\n            nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n        )\n        self.no_mask_embed = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -> torch.Tensor:\n        """\n        Returns the positional encoding used to encode point prompts,\n        applied to a dense set of points the shape of the image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape\n            1x(embed_dim)x(embedding_h)x(embedding_w)\n        """\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n        pad: bool,\n    ) -> torch.Tensor:\n        """Embeds point prompts."""\n        points = points + 0.5  # Shift to center of pixel\n        if pad:\n            padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)\n            padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)\n            points = torch.cat([points, padding_point], dim=1)\n            labels = torch.cat([labels, padding_label], dim=1)\n        point_embedding = self.pe_layer.forward_with_coords(\n            points, self.input_image_size\n        )\n        point_embedding[labels == -1] = 0.0\n        point_embedding[labels == -1] += self.not_a_point_embed.weight\n        point_embedding[labels == 0] += self.point_embeddings[0].weight\n        point_embedding[labels == 1] += self.point_embeddings[1].weight\n        point_embedding[labels == 2] += self.point_embeddings[2].weight\n        point_embedding[labels == 3] += self.point_embeddings[3].weight\n        return point_embedding\n\n    def _embed_boxes(self, boxes: torch.Tensor) -> torch.Tensor:\n        """Embeds box prompts."""\n        boxes = boxes + 0.5  # Shift to center of pixel\n        coords = boxes.reshape(-1, 2, 2)\n        corner_embedding = self.pe_layer.forward_with_coords(\n            coords, self.input_image_size\n        )\n        corner_embedding[:, 0, :] += self.point_embeddings[2].weight\n        corner_embedding[:, 1, :] += self.point_embeddings[3].weight\n        return corner_embedding\n\n    def _embed_masks(self, masks: torch.Tensor) -> torch.Tensor:\n        """Embeds mask inputs."""\n        mask_embedding = self.mask_downscaling(masks)\n        return mask_embedding\n\n    def _get_batch_size(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -> int:\n        """\n        Gets the batch size of the output given the batch size of the input prompts.\n        """\n        if points is not None:\n            return points[0].shape[0]\n        elif boxes is not None:\n            return boxes.shape[0]\n        elif masks is not None:\n            return masks.shape[0]\n        else:\n            return 1\n\n    def _get_device(self) -> torch.device:\n        return self.point_embeddings[0].weight.device\n\n    def forward(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        """\n        Embeds different types of prompts, returning both sparse and dense\n        embeddings.\n\n        Arguments:\n          points (tuple(torch.Tensor, torch.Tensor) or none): point coordinates\n            and labels to embed.\n          boxes (torch.Tensor or none): boxes to embed\n          masks (torch.Tensor or none): masks to embed\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape\n            BxNx(embed_dim), where N is determined by the number of input points\n            and boxes.\n          torch.Tensor: dense embeddings for the masks, in the shape\n            Bx(embed_dim)x(embed_H)x(embed_W)\n        """\n        bs = self._get_batch_size(points, boxes, masks)\n        sparse_embeddings = torch.empty(\n            (bs, 0, self.embed_dim), device=self._get_device()\n        )\n        if points is not None:\n            coords, labels = points\n            point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n            sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n        if boxes is not None:\n            box_embeddings = self._embed_boxes(boxes)\n            sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n        if masks is not None:\n            dense_embeddings = self._embed_masks(masks)\n        else:\n            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n            )\n\n        return sparse_embeddings, dense_embeddings\n',
    'sam2.modeling.sam.transformer': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport contextlib\nimport math\nimport warnings\nfrom functools import partial\nfrom typing import Tuple, Type\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import nn, Tensor\n\nfrom sam2.modeling.position_encoding import apply_rotary_enc, compute_axial_cis\nfrom sam2.modeling.sam2_utils import MLP\nfrom sam2.utils.misc import get_sdpa_settings\n\nwarnings.simplefilter(action="ignore", category=FutureWarning)\n# Check whether Flash Attention is available (and use it by default)\nOLD_GPU, USE_FLASH_ATTN, MATH_KERNEL_ON = get_sdpa_settings()\n# A fallback setting to allow all available kernels if Flash Attention fails\nALLOW_ALL_KERNELS = False\n\n\ndef sdp_kernel_context(dropout_p):\n    """\n    Get the context for the attention scaled dot-product kernel. We use Flash Attention\n    by default, but fall back to all available kernels if Flash Attention fails.\n    """\n    if ALLOW_ALL_KERNELS:\n        return contextlib.nullcontext()\n\n    return torch.backends.cuda.sdp_kernel(\n        enable_flash=USE_FLASH_ATTN,\n        # if Flash attention kernel is off, then math kernel needs to be enabled\n        enable_math=(OLD_GPU and dropout_p > 0.0) or MATH_KERNEL_ON,\n        enable_mem_efficient=OLD_GPU,\n    )\n\n\nclass TwoWayTransformer(nn.Module):\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n    ) -> None:\n        """\n        A transformer decoder that attends to an input image using\n        queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        """\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            self.layers.append(\n                TwoWayAttentionBlock(\n                    embedding_dim=embedding_dim,\n                    num_heads=num_heads,\n                    mlp_dim=mlp_dim,\n                    activation=activation,\n                    attention_downsample_rate=attention_downsample_rate,\n                    skip_first_layer_pe=(i == 0),\n                )\n            )\n\n        self.final_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -> Tuple[Tensor, Tensor]:\n        """\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape\n            B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must\n            have the same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          torch.Tensor: the processed point_embedding\n          torch.Tensor: the processed image_embedding\n        """\n        # BxCxHxW -> BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for layer in self.layers:\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attention layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n\n        return queries, keys\n\n\nclass TwoWayAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int = 2048,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -> None:\n        """\n        A transformer block with four layers: (1) self-attention of sparse\n        inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp\n        block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Arguments:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        """\n        super().__init__()\n        self.self_attn = Attention(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLP(\n            embedding_dim, mlp_dim, embedding_dim, num_layers=2, activation=activation\n        )\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(\n        self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor\n    ) -> Tuple[Tensor, Tensor]:\n        # Self attention block\n        if self.skip_first_layer_pe:\n            queries = self.self_attn(q=queries, k=queries, v=queries)\n        else:\n            q = queries + query_pe\n            attn_out = self.self_attn(q=q, k=q, v=queries)\n            queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys\n\n\nclass Attention(nn.Module):\n    """\n    An attention layer that allows for downscaling the size of the embedding\n    after projection to queries, keys, and values.\n    """\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n        dropout: float = 0.0,\n        kv_in_dim: int = None,\n    ) -> None:\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.kv_in_dim = kv_in_dim if kv_in_dim is not None else embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert (\n            self.internal_dim % num_heads == 0\n        ), "num_heads must divide embedding_dim."\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n        self.v_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n\n        self.dropout_p = dropout\n\n    def _separate_heads(self, x: Tensor, num_heads: int) -> Tensor:\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    def _recombine_heads(self, x: Tensor) -> Tensor:\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        dropout_p = self.dropout_p if self.training else 0.0\n        # Attention\n        try:\n            with sdp_kernel_context(dropout_p):\n                out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n        except Exception as e:\n            # Fall back to all kernels if the Flash attention kernel fails\n            warnings.warn(\n                f"Flash Attention kernel failed due to: {e}\\nFalling back to all available "\n                f"kernels for scaled_dot_product_attention (which may have a slower speed).",\n                category=UserWarning,\n                stacklevel=2,\n            )\n            global ALLOW_ALL_KERNELS\n            ALLOW_ALL_KERNELS = True\n            out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out\n\n\nclass RoPEAttention(Attention):\n    """Attention with rotary position encoding."""\n\n    def __init__(\n        self,\n        *args,\n        rope_theta=10000.0,\n        # whether to repeat q rope to match k length\n        # this is needed for cross-attention to memories\n        rope_k_repeat=False,\n        feat_sizes=(32, 32),  # [w, h] for stride 16 feats at 512 resolution\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n\n        self.compute_cis = partial(\n            compute_axial_cis, dim=self.internal_dim // self.num_heads, theta=rope_theta\n        )\n        freqs_cis = self.compute_cis(end_x=feat_sizes[0], end_y=feat_sizes[1])\n        self.freqs_cis = freqs_cis\n        self.rope_k_repeat = rope_k_repeat\n\n    def forward(\n        self, q: Tensor, k: Tensor, v: Tensor, num_k_exclude_rope: int = 0\n    ) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Apply rotary position encoding\n        w = h = math.sqrt(q.shape[-2])\n        self.freqs_cis = self.freqs_cis.to(q.device)\n        if self.freqs_cis.shape[0] != q.shape[-2]:\n            self.freqs_cis = self.compute_cis(end_x=w, end_y=h).to(q.device)\n        if q.shape[-2] != k.shape[-2]:\n            assert self.rope_k_repeat\n\n        num_k_rope = k.size(-2) - num_k_exclude_rope\n        q, k[:, :, :num_k_rope] = apply_rotary_enc(\n            q,\n            k[:, :, :num_k_rope],\n            freqs_cis=self.freqs_cis,\n            repeat_freqs_k=self.rope_k_repeat,\n        )\n\n        dropout_p = self.dropout_p if self.training else 0.0\n        # Attention\n        try:\n            with sdp_kernel_context(dropout_p):\n                out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n        except Exception as e:\n            # Fall back to all kernels if the Flash attention kernel fails\n            warnings.warn(\n                f"Flash Attention kernel failed due to: {e}\\nFalling back to all available "\n                f"kernels for scaled_dot_product_attention (which may have a slower speed).",\n                category=UserWarning,\n                stacklevel=2,\n            )\n            global ALLOW_ALL_KERNELS\n            ALLOW_ALL_KERNELS = True\n            out = F.scaled_dot_product_attention(q, k, v, dropout_p=dropout_p)\n\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out\n',
    'sam2.modeling.sam2_base': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\nimport torch.distributed\nimport torch.nn.functional as F\n\nfrom torch.nn.init import trunc_normal_\n\nfrom sam2.modeling.sam.mask_decoder import MaskDecoder\nfrom sam2.modeling.sam.prompt_encoder import PromptEncoder\nfrom sam2.modeling.sam.transformer import TwoWayTransformer\nfrom sam2.modeling.sam2_utils import get_1d_sine_pe, MLP, select_closest_cond_frames\n\n# a large negative value as a placeholder score for missing objects\nNO_OBJ_SCORE = -1024.0\n\n\nclass SAM2Base(torch.nn.Module):\n    def __init__(\n        self,\n        image_encoder,\n        memory_attention,\n        memory_encoder,\n        num_maskmem=7,  # default 1 input frame + 6 previous frames\n        image_size=512,\n        backbone_stride=16,  # stride of the image backbone output\n        sigmoid_scale_for_mem_enc=1.0,  # scale factor for mask sigmoid prob\n        sigmoid_bias_for_mem_enc=0.0,  # bias factor for mask sigmoid prob\n        # During evaluation, whether to binarize the sigmoid mask logits on interacted frames with clicks\n        binarize_mask_from_pts_for_mem_enc=False,\n        use_mask_input_as_output_without_sam=False,  # on frames with mask input, whether to directly output the input mask without using a SAM prompt encoder + mask decoder\n        # The maximum number of conditioning frames to participate in the memory attention (-1 means no limit; if there are more conditioning frames than this limit,\n        # we only cross-attend to the temporally closest `max_cond_frames_in_attn` conditioning frames in the encoder when tracking each frame). This gives the model\n        # a temporal locality when handling a large number of annotated frames (since closer frames should be more important) and also avoids GPU OOM.\n        max_cond_frames_in_attn=-1,\n        # on the first frame, whether to directly add the no-memory embedding to the image feature\n        # (instead of using the transformer encoder)\n        directly_add_no_mem_embed=False,\n        # whether to use high-resolution feature maps in the SAM mask decoder\n        use_high_res_features_in_sam=False,\n        # whether to output multiple (3) masks for the first click on initial conditioning frames\n        multimask_output_in_sam=False,\n        # the minimum and maximum number of clicks to use multimask_output_in_sam (only relevant when `multimask_output_in_sam=True`;\n        # default is 1 for both, meaning that only the first click gives multimask output; also note that a box counts as two points)\n        multimask_min_pt_num=1,\n        multimask_max_pt_num=1,\n        # whether to also use multimask output for tracking (not just for the first click on initial conditioning frames; only relevant when `multimask_output_in_sam=True`)\n        multimask_output_for_tracking=False,\n        # Whether to use multimask tokens for obj ptr; Only relevant when both\n        # use_obj_ptrs_in_encoder=True and multimask_output_for_tracking=True\n        use_multimask_token_for_obj_ptr: bool = False,\n        # whether to use sigmoid to restrict ious prediction to [0-1]\n        iou_prediction_use_sigmoid=False,\n        # The memory bank\'s temporal stride during evaluation (i.e. the `r` parameter in XMem and Cutie; XMem and Cutie use r=5).\n        # For r>1, the (self.num_maskmem - 1) non-conditioning memory frames consist of\n        # (self.num_maskmem - 2) nearest frames from every r-th frames, plus the last frame.\n        memory_temporal_stride_for_eval=1,\n        # whether to apply non-overlapping constraints on the object masks in the memory encoder during evaluation (to avoid/alleviate superposing masks)\n        non_overlap_masks_for_mem_enc=False,\n        # whether to cross-attend to object pointers from other frames (based on SAM output tokens) in the encoder\n        use_obj_ptrs_in_encoder=False,\n        # the maximum number of object pointers from other frames in encoder cross attention (only relevant when `use_obj_ptrs_in_encoder=True`)\n        max_obj_ptrs_in_encoder=16,\n        # whether to add temporal positional encoding to the object pointers in the encoder (only relevant when `use_obj_ptrs_in_encoder=True`)\n        add_tpos_enc_to_obj_ptrs=True,\n        # whether to add an extra linear projection layer for the temporal positional encoding in the object pointers to avoid potential interference\n        # with spatial positional encoding (only relevant when both `use_obj_ptrs_in_encoder=True` and `add_tpos_enc_to_obj_ptrs=True`)\n        proj_tpos_enc_in_obj_ptrs=False,\n        # whether to use signed distance (instead of unsigned absolute distance) in the temporal positional encoding in the object pointers\n        # (only relevant when both `use_obj_ptrs_in_encoder=True` and `add_tpos_enc_to_obj_ptrs=True`)\n        use_signed_tpos_enc_to_obj_ptrs=False,\n        # whether to only attend to object pointers in the past (before the current frame) in the encoder during evaluation\n        # (only relevant when `use_obj_ptrs_in_encoder=True`; this might avoid pointer information too far in the future to distract the initial tracking)\n        only_obj_ptrs_in_the_past_for_eval=False,\n        # Whether to predict if there is an object in the frame\n        pred_obj_scores: bool = False,\n        # Whether to use an MLP to predict object scores\n        pred_obj_scores_mlp: bool = False,\n        # Only relevant if pred_obj_scores=True and use_obj_ptrs_in_encoder=True;\n        # Whether to have a fixed no obj pointer when there is no object present\n        # or to use it as an additive embedding with obj_ptr produced by decoder\n        fixed_no_obj_ptr: bool = False,\n        # Soft no object, i.e. mix in no_obj_ptr softly,\n        # hope to make recovery easier if there is a mistake and mitigate accumulation of errors\n        soft_no_obj_ptr: bool = False,\n        use_mlp_for_obj_ptr_proj: bool = False,\n        # add no obj embedding to spatial frames\n        no_obj_embed_spatial: bool = False,\n        # extra arguments used to construct the SAM mask decoder; if not None, it should be a dict of kwargs to be passed into `MaskDecoder` class.\n        sam_mask_decoder_extra_args=None,\n        compile_image_encoder: bool = False,\n    ):\n        super().__init__()\n\n        # Part 1: the image backbone\n        self.image_encoder = image_encoder\n        # Use level 0, 1, 2 for high-res setting, or just level 2 for the default setting\n        self.use_high_res_features_in_sam = use_high_res_features_in_sam\n        self.num_feature_levels = 3 if use_high_res_features_in_sam else 1\n        self.use_obj_ptrs_in_encoder = use_obj_ptrs_in_encoder\n        self.max_obj_ptrs_in_encoder = max_obj_ptrs_in_encoder\n        if use_obj_ptrs_in_encoder:\n            # A conv layer to downsample the mask prompt to stride 4 (the same stride as\n            # low-res SAM mask logits) and to change its scales from 0~1 to SAM logit scale,\n            # so that it can be fed into the SAM mask decoder to generate a pointer.\n            self.mask_downsample = torch.nn.Conv2d(1, 1, kernel_size=4, stride=4)\n        self.add_tpos_enc_to_obj_ptrs = add_tpos_enc_to_obj_ptrs\n        if proj_tpos_enc_in_obj_ptrs:\n            assert add_tpos_enc_to_obj_ptrs  # these options need to be used together\n        self.proj_tpos_enc_in_obj_ptrs = proj_tpos_enc_in_obj_ptrs\n        self.use_signed_tpos_enc_to_obj_ptrs = use_signed_tpos_enc_to_obj_ptrs\n        self.only_obj_ptrs_in_the_past_for_eval = only_obj_ptrs_in_the_past_for_eval\n\n        # Part 2: memory attention to condition current frame\'s visual features\n        # with memories (and obj ptrs) from past frames\n        self.memory_attention = memory_attention\n        self.hidden_dim = image_encoder.neck.d_model\n\n        # Part 3: memory encoder for the previous frame\'s outputs\n        self.memory_encoder = memory_encoder\n        self.mem_dim = self.hidden_dim\n        if hasattr(self.memory_encoder, "out_proj") and hasattr(\n            self.memory_encoder.out_proj, "weight"\n        ):\n            # if there is compression of memories along channel dim\n            self.mem_dim = self.memory_encoder.out_proj.weight.shape[0]\n        self.num_maskmem = num_maskmem  # Number of memories accessible\n        # Temporal encoding of the memories\n        self.maskmem_tpos_enc = torch.nn.Parameter(\n            torch.zeros(num_maskmem, 1, 1, self.mem_dim)\n        )\n        trunc_normal_(self.maskmem_tpos_enc, std=0.02)\n        # a single token to indicate no memory embedding from previous frames\n        self.no_mem_embed = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        self.no_mem_pos_enc = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n        trunc_normal_(self.no_mem_embed, std=0.02)\n        trunc_normal_(self.no_mem_pos_enc, std=0.02)\n        self.directly_add_no_mem_embed = directly_add_no_mem_embed\n        # Apply sigmoid to the output raw mask logits (to turn them from\n        # range (-inf, +inf) to range (0, 1)) before feeding them into the memory encoder\n        self.sigmoid_scale_for_mem_enc = sigmoid_scale_for_mem_enc\n        self.sigmoid_bias_for_mem_enc = sigmoid_bias_for_mem_enc\n        self.binarize_mask_from_pts_for_mem_enc = binarize_mask_from_pts_for_mem_enc\n        self.non_overlap_masks_for_mem_enc = non_overlap_masks_for_mem_enc\n        self.memory_temporal_stride_for_eval = memory_temporal_stride_for_eval\n        # On frames with mask input, whether to directly output the input mask without\n        # using a SAM prompt encoder + mask decoder\n        self.use_mask_input_as_output_without_sam = use_mask_input_as_output_without_sam\n        self.multimask_output_in_sam = multimask_output_in_sam\n        self.multimask_min_pt_num = multimask_min_pt_num\n        self.multimask_max_pt_num = multimask_max_pt_num\n        self.multimask_output_for_tracking = multimask_output_for_tracking\n        self.use_multimask_token_for_obj_ptr = use_multimask_token_for_obj_ptr\n        self.iou_prediction_use_sigmoid = iou_prediction_use_sigmoid\n\n        # Part 4: SAM-style prompt encoder (for both mask and point inputs)\n        # and SAM-style mask decoder for the final mask output\n        self.image_size = image_size\n        self.backbone_stride = backbone_stride\n        self.sam_mask_decoder_extra_args = sam_mask_decoder_extra_args\n        self.pred_obj_scores = pred_obj_scores\n        self.pred_obj_scores_mlp = pred_obj_scores_mlp\n        self.fixed_no_obj_ptr = fixed_no_obj_ptr\n        self.soft_no_obj_ptr = soft_no_obj_ptr\n        if self.fixed_no_obj_ptr:\n            assert self.pred_obj_scores\n            assert self.use_obj_ptrs_in_encoder\n        if self.pred_obj_scores and self.use_obj_ptrs_in_encoder:\n            self.no_obj_ptr = torch.nn.Parameter(torch.zeros(1, self.hidden_dim))\n            trunc_normal_(self.no_obj_ptr, std=0.02)\n        self.use_mlp_for_obj_ptr_proj = use_mlp_for_obj_ptr_proj\n        self.no_obj_embed_spatial = None\n        if no_obj_embed_spatial:\n            self.no_obj_embed_spatial = torch.nn.Parameter(torch.zeros(1, self.mem_dim))\n            trunc_normal_(self.no_obj_embed_spatial, std=0.02)\n\n        self._build_sam_heads()\n        self.max_cond_frames_in_attn = max_cond_frames_in_attn\n\n        # Model compilation\n        if compile_image_encoder:\n            # Compile the forward function (not the full module) to allow loading checkpoints.\n            print(\n                "Image encoder compilation is enabled. First forward pass will be slow."\n            )\n            self.image_encoder.forward = torch.compile(\n                self.image_encoder.forward,\n                mode="max-autotune",\n                fullgraph=True,\n                dynamic=False,\n            )\n\n    @property\n    def device(self):\n        return next(self.parameters()).device\n\n    def forward(self, *args, **kwargs):\n        raise NotImplementedError(\n            "Please use the corresponding methods in SAM2VideoPredictor for inference or SAM2Train for training/fine-tuning"\n            "See notebooks/video_predictor_example.ipynb for an inference example."\n        )\n\n    def _build_sam_heads(self):\n        """Build SAM-style prompt encoder and mask decoder."""\n        self.sam_prompt_embed_dim = self.hidden_dim\n        self.sam_image_embedding_size = self.image_size // self.backbone_stride\n\n        # build PromptEncoder and MaskDecoder from SAM\n        # (their hyperparameters like `mask_in_chans=16` are from SAM code)\n        self.sam_prompt_encoder = PromptEncoder(\n            embed_dim=self.sam_prompt_embed_dim,\n            image_embedding_size=(\n                self.sam_image_embedding_size,\n                self.sam_image_embedding_size,\n            ),\n            input_image_size=(self.image_size, self.image_size),\n            mask_in_chans=16,\n        )\n        self.sam_mask_decoder = MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=self.sam_prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=self.sam_prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n            use_high_res_features=self.use_high_res_features_in_sam,\n            iou_prediction_use_sigmoid=self.iou_prediction_use_sigmoid,\n            pred_obj_scores=self.pred_obj_scores,\n            pred_obj_scores_mlp=self.pred_obj_scores_mlp,\n            use_multimask_token_for_obj_ptr=self.use_multimask_token_for_obj_ptr,\n            **(self.sam_mask_decoder_extra_args or {}),\n        )\n        if self.use_obj_ptrs_in_encoder:\n            # a linear projection on SAM output tokens to turn them into object pointers\n            self.obj_ptr_proj = torch.nn.Linear(self.hidden_dim, self.hidden_dim)\n            if self.use_mlp_for_obj_ptr_proj:\n                self.obj_ptr_proj = MLP(\n                    self.hidden_dim, self.hidden_dim, self.hidden_dim, 3\n                )\n        else:\n            self.obj_ptr_proj = torch.nn.Identity()\n        if self.proj_tpos_enc_in_obj_ptrs:\n            # a linear projection on temporal positional encoding in object pointers to\n            # avoid potential interference with spatial positional encoding\n            self.obj_ptr_tpos_proj = torch.nn.Linear(self.hidden_dim, self.mem_dim)\n        else:\n            self.obj_ptr_tpos_proj = torch.nn.Identity()\n\n    def _forward_sam_heads(\n        self,\n        backbone_features,\n        point_inputs=None,\n        mask_inputs=None,\n        high_res_features=None,\n        multimask_output=False,\n    ):\n        """\n        Forward SAM prompt encoders and mask heads.\n\n        Inputs:\n        - backbone_features: image features of [B, C, H, W] shape\n        - point_inputs: a dictionary with "point_coords" and "point_labels", where\n          1) "point_coords" has [B, P, 2] shape and float32 dtype and contains the\n             absolute pixel-unit coordinate in (x, y) format of the P input points\n          2) "point_labels" has shape [B, P] and int32 dtype, where 1 means\n             positive clicks, 0 means negative clicks, and -1 means padding\n        - mask_inputs: a mask of [B, 1, H*16, W*16] shape, float or bool, with the\n          same spatial size as the image.\n        - high_res_features: either 1) None or 2) or a list of length 2 containing\n          two feature maps of [B, C, 4*H, 4*W] and [B, C, 2*H, 2*W] shapes respectively,\n          which will be used as high-resolution feature maps for SAM decoder.\n        - multimask_output: if it\'s True, we output 3 candidate masks and their 3\n          corresponding IoU estimates, and if it\'s False, we output only 1 mask and\n          its corresponding IoU estimate.\n\n        Outputs:\n        - low_res_multimasks: [B, M, H*4, W*4] shape (where M = 3 if\n          `multimask_output=True` and M = 1 if `multimask_output=False`), the SAM\n          output mask logits (before sigmoid) for the low-resolution masks, with 4x\n          the resolution (1/4 stride) of the input backbone_features.\n        - high_res_multimasks: [B, M, H*16, W*16] shape (where M = 3\n          if `multimask_output=True` and M = 1 if `multimask_output=False`),\n          upsampled from the low-resolution masks, with shape size as the image\n          (stride is 1 pixel).\n        - ious, [B, M] shape, where (where M = 3 if `multimask_output=True` and M = 1\n          if `multimask_output=False`), the estimated IoU of each output mask.\n        - low_res_masks: [B, 1, H*4, W*4] shape, the best mask in `low_res_multimasks`.\n          If `multimask_output=True`, it\'s the mask with the highest IoU estimate.\n          If `multimask_output=False`, it\'s the same as `low_res_multimasks`.\n        - high_res_masks: [B, 1, H*16, W*16] shape, the best mask in `high_res_multimasks`.\n          If `multimask_output=True`, it\'s the mask with the highest IoU estimate.\n          If `multimask_output=False`, it\'s the same as `high_res_multimasks`.\n        - obj_ptr: [B, C] shape, the object pointer vector for the output mask, extracted\n          based on the output token from the SAM mask decoder.\n        """\n        B = backbone_features.size(0)\n        device = backbone_features.device\n        assert backbone_features.size(1) == self.sam_prompt_embed_dim\n        assert backbone_features.size(2) == self.sam_image_embedding_size\n        assert backbone_features.size(3) == self.sam_image_embedding_size\n\n        # a) Handle point prompts\n        if point_inputs is not None:\n            sam_point_coords = point_inputs["point_coords"]\n            sam_point_labels = point_inputs["point_labels"]\n            assert sam_point_coords.size(0) == B and sam_point_labels.size(0) == B\n        else:\n            # If no points are provide, pad with an empty point (with label -1)\n            sam_point_coords = torch.zeros(B, 1, 2, device=device)\n            sam_point_labels = -torch.ones(B, 1, dtype=torch.int32, device=device)\n\n        # b) Handle mask prompts\n        if mask_inputs is not None:\n            # If mask_inputs is provided, downsize it into low-res mask input if needed\n            # and feed it as a dense mask prompt into the SAM mask encoder\n            assert len(mask_inputs.shape) == 4 and mask_inputs.shape[:2] == (B, 1)\n            if mask_inputs.shape[-2:] != self.sam_prompt_encoder.mask_input_size:\n                sam_mask_prompt = F.interpolate(\n                    mask_inputs.float(),\n                    size=self.sam_prompt_encoder.mask_input_size,\n                    align_corners=False,\n                    mode="bilinear",\n                    antialias=True,  # use antialias for downsampling\n                )\n            else:\n                sam_mask_prompt = mask_inputs\n        else:\n            # Otherwise, simply feed None (and SAM\'s prompt encoder will add\n            # a learned `no_mask_embed` to indicate no mask input in this case).\n            sam_mask_prompt = None\n\n        sparse_embeddings, dense_embeddings = self.sam_prompt_encoder(\n            points=(sam_point_coords, sam_point_labels),\n            boxes=None,\n            masks=sam_mask_prompt,\n        )\n        (\n            low_res_multimasks,\n            ious,\n            sam_output_tokens,\n            object_score_logits,\n        ) = self.sam_mask_decoder(\n            image_embeddings=backbone_features,\n            image_pe=self.sam_prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n            repeat_image=False,  # the image is already batched\n            high_res_features=high_res_features,\n        )\n        if self.pred_obj_scores:\n            is_obj_appearing = object_score_logits > 0\n\n            # Mask used for spatial memories is always a *hard* choice between obj and no obj,\n            # consistent with the actual mask prediction\n            low_res_multimasks = torch.where(\n                is_obj_appearing[:, None, None],\n                low_res_multimasks,\n                NO_OBJ_SCORE,\n            )\n\n        # convert masks from possibly bfloat16 (or float16) to float32\n        # (older PyTorch versions before 2.1 don\'t support `interpolate` on bf16)\n        low_res_multimasks = low_res_multimasks.float()\n        high_res_multimasks = F.interpolate(\n            low_res_multimasks,\n            size=(self.image_size, self.image_size),\n            mode="bilinear",\n            align_corners=False,\n        )\n\n        sam_output_token = sam_output_tokens[:, 0]\n        if multimask_output:\n            # take the best mask prediction (with the highest IoU estimation)\n            best_iou_inds = torch.argmax(ious, dim=-1)\n            batch_inds = torch.arange(B, device=device)\n            low_res_masks = low_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            high_res_masks = high_res_multimasks[batch_inds, best_iou_inds].unsqueeze(1)\n            if sam_output_tokens.size(1) > 1:\n                sam_output_token = sam_output_tokens[batch_inds, best_iou_inds]\n        else:\n            low_res_masks, high_res_masks = low_res_multimasks, high_res_multimasks\n\n        # Extract object pointer from the SAM output token (with occlusion handling)\n        obj_ptr = self.obj_ptr_proj(sam_output_token)\n        if self.pred_obj_scores:\n            # Allow *soft* no obj ptr, unlike for masks\n            if self.soft_no_obj_ptr:\n                lambda_is_obj_appearing = object_score_logits.sigmoid()\n            else:\n                lambda_is_obj_appearing = is_obj_appearing.float()\n\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_multimasks,\n            high_res_multimasks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def _use_mask_as_output(self, backbone_features, high_res_features, mask_inputs):\n        """\n        Directly turn binary `mask_inputs` into a output mask logits without using SAM.\n        (same input and output shapes as in _forward_sam_heads above).\n        """\n        # Use -10/+10 as logits for neg/pos pixels (very close to 0/1 in prob after sigmoid).\n        out_scale, out_bias = 20.0, -10.0  # sigmoid(-10.0)=4.5398e-05\n        mask_inputs_float = mask_inputs.float()\n        high_res_masks = mask_inputs_float * out_scale + out_bias\n        low_res_masks = F.interpolate(\n            high_res_masks,\n            size=(high_res_masks.size(-2) // 4, high_res_masks.size(-1) // 4),\n            align_corners=False,\n            mode="bilinear",\n            antialias=True,  # use antialias for downsampling\n        )\n        # a dummy IoU prediction of all 1\'s under mask input\n        ious = mask_inputs.new_ones(mask_inputs.size(0), 1).float()\n        if not self.use_obj_ptrs_in_encoder:\n            # all zeros as a dummy object pointer (of shape [B, C])\n            obj_ptr = torch.zeros(\n                mask_inputs.size(0), self.hidden_dim, device=mask_inputs.device\n            )\n        else:\n            # produce an object pointer using the SAM decoder from the mask input\n            _, _, _, _, _, obj_ptr, _ = self._forward_sam_heads(\n                backbone_features=backbone_features,\n                mask_inputs=self.mask_downsample(mask_inputs_float),\n                high_res_features=high_res_features,\n            )\n        # In this method, we are treating mask_input as output, e.g. using it directly to create spatial mem;\n        # Below, we follow the same design axiom to use mask_input to decide if obj appears or not instead of relying\n        # on the object_scores from the SAM decoder.\n        is_obj_appearing = torch.any(mask_inputs.flatten(1).float() > 0.0, dim=1)\n        is_obj_appearing = is_obj_appearing[..., None]\n        lambda_is_obj_appearing = is_obj_appearing.float()\n        object_score_logits = out_scale * lambda_is_obj_appearing + out_bias\n        if self.pred_obj_scores:\n            if self.fixed_no_obj_ptr:\n                obj_ptr = lambda_is_obj_appearing * obj_ptr\n            obj_ptr = obj_ptr + (1 - lambda_is_obj_appearing) * self.no_obj_ptr\n\n        return (\n            low_res_masks,\n            high_res_masks,\n            ious,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        )\n\n    def forward_image(self, img_batch: torch.Tensor):\n        """Get the image feature on the input batch."""\n        backbone_out = self.image_encoder(img_batch)\n        if self.use_high_res_features_in_sam:\n            # precompute projected level 0 and level 1 features in SAM decoder\n            # to avoid running it again on every SAM click\n            backbone_out["backbone_fpn"][0] = self.sam_mask_decoder.conv_s0(\n                backbone_out["backbone_fpn"][0]\n            )\n            backbone_out["backbone_fpn"][1] = self.sam_mask_decoder.conv_s1(\n                backbone_out["backbone_fpn"][1]\n            )\n        return backbone_out\n\n    def _prepare_backbone_features(self, backbone_out):\n        """Prepare and flatten visual features."""\n        backbone_out = backbone_out.copy()\n        assert len(backbone_out["backbone_fpn"]) == len(backbone_out["vision_pos_enc"])\n        assert len(backbone_out["backbone_fpn"]) >= self.num_feature_levels\n\n        feature_maps = backbone_out["backbone_fpn"][-self.num_feature_levels :]\n        vision_pos_embeds = backbone_out["vision_pos_enc"][-self.num_feature_levels :]\n\n        feat_sizes = [(x.shape[-2], x.shape[-1]) for x in vision_pos_embeds]\n        # flatten NxCxHxW to HWxNxC\n        vision_feats = [x.flatten(2).permute(2, 0, 1) for x in feature_maps]\n        vision_pos_embeds = [x.flatten(2).permute(2, 0, 1) for x in vision_pos_embeds]\n\n        return backbone_out, vision_feats, vision_pos_embeds, feat_sizes\n\n    def _prepare_memory_conditioned_features(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n    ):\n        """Fuse the current frame\'s visual feature map with previous memory."""\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        device = current_vision_feats[-1].device\n        # The case of `self.num_maskmem == 0` below is primarily used for reproducing SAM on images.\n        # In this case, we skip the fusion with any memory.\n        if self.num_maskmem == 0:  # Disable memory and skip fusion\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n            return pix_feat\n\n        num_obj_ptr_tokens = 0\n        tpos_sign_mul = -1 if track_in_reverse else 1\n        # Step 1: condition the visual features of the current frame on previous memories\n        if not is_init_cond_frame:\n            # Retrieve the memories encoded with the maskmem backbone\n            to_cat_memory, to_cat_memory_pos_embed = [], []\n            # Add conditioning frames\'s output first (all cond frames have t_pos=0 for\n            # when getting temporal positional embedding below)\n            assert len(output_dict["cond_frame_outputs"]) > 0\n            # Select a maximum number of temporally closest cond frames for cross attention\n            cond_outputs = output_dict["cond_frame_outputs"]\n            selected_cond_outputs, unselected_cond_outputs = select_closest_cond_frames(\n                frame_idx, cond_outputs, self.max_cond_frames_in_attn\n            )\n            t_pos_and_prevs = [(0, out) for out in selected_cond_outputs.values()]\n            # Add last (self.num_maskmem - 1) frames before current frame for non-conditioning memory\n            # the earliest one has t_pos=1 and the latest one has t_pos=self.num_maskmem-1\n            # We also allow taking the memory frame non-consecutively (with stride>1), in which case\n            # we take (self.num_maskmem - 2) frames among every stride-th frames plus the last frame.\n            stride = 1 if self.training else self.memory_temporal_stride_for_eval\n            for t_pos in range(1, self.num_maskmem):\n                t_rel = self.num_maskmem - t_pos  # how many frames before current frame\n                if t_rel == 1:\n                    # for t_rel == 1, we take the last frame (regardless of r)\n                    if not track_in_reverse:\n                        # the frame immediately before this frame (i.e. frame_idx - 1)\n                        prev_frame_idx = frame_idx - t_rel\n                    else:\n                        # the frame immediately after this frame (i.e. frame_idx + 1)\n                        prev_frame_idx = frame_idx + t_rel\n                else:\n                    # for t_rel >= 2, we take the memory frame from every r-th frames\n                    if not track_in_reverse:\n                        # first find the nearest frame among every r-th frames before this frame\n                        # for r=1, this would be (frame_idx - 2)\n                        prev_frame_idx = ((frame_idx - 2) // stride) * stride\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx - (t_rel - 2) * stride\n                    else:\n                        # first find the nearest frame among every r-th frames after this frame\n                        # for r=1, this would be (frame_idx + 2)\n                        prev_frame_idx = -(-(frame_idx + 2) // stride) * stride\n                        # then seek further among every r-th frames\n                        prev_frame_idx = prev_frame_idx + (t_rel - 2) * stride\n                out = output_dict["non_cond_frame_outputs"].get(prev_frame_idx, None)\n                if out is None:\n                    # If an unselected conditioning frame is among the last (self.num_maskmem - 1)\n                    # frames, we still attend to it as if it\'s a non-conditioning frame.\n                    out = unselected_cond_outputs.get(prev_frame_idx, None)\n                t_pos_and_prevs.append((t_pos, out))\n\n            for t_pos, prev in t_pos_and_prevs:\n                if prev is None:\n                    continue  # skip padding frames\n                # "maskmem_features" might have been offloaded to CPU in demo use cases,\n                # so we load it back to GPU (it\'s a no-op if it\'s already on GPU).\n                feats = prev["maskmem_features"].to(device, non_blocking=True)\n                to_cat_memory.append(feats.flatten(2).permute(2, 0, 1))\n                # Spatial positional encoding (it might have been offloaded to CPU in eval)\n                maskmem_enc = prev["maskmem_pos_enc"][-1].to(device)\n                maskmem_enc = maskmem_enc.flatten(2).permute(2, 0, 1)\n                # Temporal positional encoding\n                maskmem_enc = (\n                    maskmem_enc + self.maskmem_tpos_enc[self.num_maskmem - t_pos - 1]\n                )\n                to_cat_memory_pos_embed.append(maskmem_enc)\n\n            # Construct the list of past object pointers\n            if self.use_obj_ptrs_in_encoder:\n                max_obj_ptrs_in_encoder = min(num_frames, self.max_obj_ptrs_in_encoder)\n                # First add those object pointers from selected conditioning frames\n                # (optionally, only include object pointers in the past during evaluation)\n                if not self.training and self.only_obj_ptrs_in_the_past_for_eval:\n                    ptr_cond_outputs = {\n                        t: out\n                        for t, out in selected_cond_outputs.items()\n                        if (t >= frame_idx if track_in_reverse else t <= frame_idx)\n                    }\n                else:\n                    ptr_cond_outputs = selected_cond_outputs\n                pos_and_ptrs = [\n                    # Temporal pos encoding contains how far away each pointer is from current frame\n                    (\n                        (\n                            (frame_idx - t) * tpos_sign_mul\n                            if self.use_signed_tpos_enc_to_obj_ptrs\n                            else abs(frame_idx - t)\n                        ),\n                        out["obj_ptr"],\n                    )\n                    for t, out in ptr_cond_outputs.items()\n                ]\n                # Add up to (max_obj_ptrs_in_encoder - 1) non-conditioning frames before current frame\n                for t_diff in range(1, max_obj_ptrs_in_encoder):\n                    t = frame_idx + t_diff if track_in_reverse else frame_idx - t_diff\n                    if t < 0 or (num_frames is not None and t >= num_frames):\n                        break\n                    out = output_dict["non_cond_frame_outputs"].get(\n                        t, unselected_cond_outputs.get(t, None)\n                    )\n                    if out is not None:\n                        pos_and_ptrs.append((t_diff, out["obj_ptr"]))\n                # If we have at least one object pointer, add them to the across attention\n                if len(pos_and_ptrs) > 0:\n                    pos_list, ptrs_list = zip(*pos_and_ptrs)\n                    # stack object pointers along dim=0 into [ptr_seq_len, B, C] shape\n                    obj_ptrs = torch.stack(ptrs_list, dim=0)\n                    # a temporal positional embedding based on how far each object pointer is from\n                    # the current frame (sine embedding normalized by the max pointer num).\n                    if self.add_tpos_enc_to_obj_ptrs:\n                        t_diff_max = max_obj_ptrs_in_encoder - 1\n                        tpos_dim = C if self.proj_tpos_enc_in_obj_ptrs else self.mem_dim\n                        obj_pos = torch.tensor(pos_list, device=device)\n                        obj_pos = get_1d_sine_pe(obj_pos / t_diff_max, dim=tpos_dim)\n                        obj_pos = self.obj_ptr_tpos_proj(obj_pos)\n                        obj_pos = obj_pos.unsqueeze(1).expand(-1, B, self.mem_dim)\n                    else:\n                        obj_pos = obj_ptrs.new_zeros(len(pos_list), B, self.mem_dim)\n                    if self.mem_dim < C:\n                        # split a pointer into (C // self.mem_dim) tokens for self.mem_dim < C\n                        obj_ptrs = obj_ptrs.reshape(\n                            -1, B, C // self.mem_dim, self.mem_dim\n                        )\n                        obj_ptrs = obj_ptrs.permute(0, 2, 1, 3).flatten(0, 1)\n                        obj_pos = obj_pos.repeat_interleave(C // self.mem_dim, dim=0)\n                    to_cat_memory.append(obj_ptrs)\n                    to_cat_memory_pos_embed.append(obj_pos)\n                    num_obj_ptr_tokens = obj_ptrs.shape[0]\n                else:\n                    num_obj_ptr_tokens = 0\n        else:\n            # for initial conditioning frames, encode them without using any previous memory\n            if self.directly_add_no_mem_embed:\n                # directly add no-mem embedding (instead of using the transformer encoder)\n                pix_feat_with_mem = current_vision_feats[-1] + self.no_mem_embed\n                pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n                return pix_feat_with_mem\n\n            # Use a dummy token on the first frame (to avoid empty memory input to tranformer encoder)\n            to_cat_memory = [self.no_mem_embed.expand(1, B, self.mem_dim)]\n            to_cat_memory_pos_embed = [self.no_mem_pos_enc.expand(1, B, self.mem_dim)]\n\n        # Step 2: Concatenate the memories and forward through the transformer encoder\n        memory = torch.cat(to_cat_memory, dim=0)\n        memory_pos_embed = torch.cat(to_cat_memory_pos_embed, dim=0)\n\n        pix_feat_with_mem = self.memory_attention(\n            curr=current_vision_feats,\n            curr_pos=current_vision_pos_embeds,\n            memory=memory,\n            memory_pos=memory_pos_embed,\n            num_obj_ptr_tokens=num_obj_ptr_tokens,\n        )\n        # reshape the output (HW)BC => BCHW\n        pix_feat_with_mem = pix_feat_with_mem.permute(1, 2, 0).view(B, C, H, W)\n        return pix_feat_with_mem\n\n    def _encode_new_memory(\n        self,\n        current_vision_feats,\n        feat_sizes,\n        pred_masks_high_res,\n        object_score_logits,\n        is_mask_from_pts,\n    ):\n        """Encode the current image and its prediction into a memory feature."""\n        B = current_vision_feats[-1].size(1)  # batch size on this frame\n        C = self.hidden_dim\n        H, W = feat_sizes[-1]  # top-level (lowest-resolution) feature size\n        # top-level feature, (HW)BC => BCHW\n        pix_feat = current_vision_feats[-1].permute(1, 2, 0).view(B, C, H, W)\n        if self.non_overlap_masks_for_mem_enc and not self.training:\n            # optionally, apply non-overlapping constraints to the masks (it\'s applied\n            # in the batch dimension and should only be used during eval, where all\n            # the objects come from the same video under batch size 1).\n            pred_masks_high_res = self._apply_non_overlapping_constraints(\n                pred_masks_high_res\n            )\n        # scale the raw mask logits with a temperature before applying sigmoid\n        binarize = self.binarize_mask_from_pts_for_mem_enc and is_mask_from_pts\n        if binarize and not self.training:\n            mask_for_mem = (pred_masks_high_res > 0).float()\n        else:\n            # apply sigmoid on the raw mask logits to turn them into range (0, 1)\n            mask_for_mem = torch.sigmoid(pred_masks_high_res)\n        # apply scale and bias terms to the sigmoid probabilities\n        if self.sigmoid_scale_for_mem_enc != 1.0:\n            mask_for_mem = mask_for_mem * self.sigmoid_scale_for_mem_enc\n        if self.sigmoid_bias_for_mem_enc != 0.0:\n            mask_for_mem = mask_for_mem + self.sigmoid_bias_for_mem_enc\n        maskmem_out = self.memory_encoder(\n            pix_feat, mask_for_mem, skip_mask_sigmoid=True  # sigmoid already applied\n        )\n        maskmem_features = maskmem_out["vision_features"]\n        maskmem_pos_enc = maskmem_out["vision_pos_enc"]\n        # add a no-object embedding to the spatial memory to indicate that the frame\n        # is predicted to be occluded (i.e. no object is appearing in the frame)\n        if self.no_obj_embed_spatial is not None:\n            is_obj_appearing = (object_score_logits > 0).float()\n            maskmem_features += (\n                1 - is_obj_appearing[..., None, None]\n            ) * self.no_obj_embed_spatial[..., None, None].expand(\n                *maskmem_features.shape\n            )\n\n        return maskmem_features, maskmem_pos_enc\n\n    def _track_step(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        point_inputs,\n        mask_inputs,\n        output_dict,\n        num_frames,\n        track_in_reverse,\n        prev_sam_mask_logits,\n    ):\n        current_out = {"point_inputs": point_inputs, "mask_inputs": mask_inputs}\n        # High-resolution feature maps for the SAM head, reshape (HW)BC => BCHW\n        if len(current_vision_feats) > 1:\n            high_res_features = [\n                x.permute(1, 2, 0).view(x.size(1), x.size(2), *s)\n                for x, s in zip(current_vision_feats[:-1], feat_sizes[:-1])\n            ]\n        else:\n            high_res_features = None\n        if mask_inputs is not None and self.use_mask_input_as_output_without_sam:\n            # When use_mask_input_as_output_without_sam=True, we directly output the mask input\n            # (see it as a GT mask) without using a SAM prompt encoder + mask decoder.\n            pix_feat = current_vision_feats[-1].permute(1, 2, 0)\n            pix_feat = pix_feat.view(-1, self.hidden_dim, *feat_sizes[-1])\n            sam_outputs = self._use_mask_as_output(\n                pix_feat, high_res_features, mask_inputs\n            )\n        else:\n            # fused the visual feature with previous memory features in the memory bank\n            pix_feat = self._prepare_memory_conditioned_features(\n                frame_idx=frame_idx,\n                is_init_cond_frame=is_init_cond_frame,\n                current_vision_feats=current_vision_feats[-1:],\n                current_vision_pos_embeds=current_vision_pos_embeds[-1:],\n                feat_sizes=feat_sizes[-1:],\n                output_dict=output_dict,\n                num_frames=num_frames,\n                track_in_reverse=track_in_reverse,\n            )\n            # apply SAM-style segmentation head\n            # here we might feed previously predicted low-res SAM mask logits into the SAM mask decoder,\n            # e.g. in demo where such logits come from earlier interaction instead of correction sampling\n            # (in this case, any `mask_inputs` shouldn\'t reach here as they are sent to _use_mask_as_output instead)\n            if prev_sam_mask_logits is not None:\n                assert point_inputs is not None and mask_inputs is None\n                mask_inputs = prev_sam_mask_logits\n            multimask_output = self._use_multimask(is_init_cond_frame, point_inputs)\n            sam_outputs = self._forward_sam_heads(\n                backbone_features=pix_feat,\n                point_inputs=point_inputs,\n                mask_inputs=mask_inputs,\n                high_res_features=high_res_features,\n                multimask_output=multimask_output,\n            )\n\n        return current_out, sam_outputs, high_res_features, pix_feat\n\n    def _encode_memory_in_output(\n        self,\n        current_vision_feats,\n        feat_sizes,\n        point_inputs,\n        run_mem_encoder,\n        high_res_masks,\n        object_score_logits,\n        current_out,\n    ):\n        if run_mem_encoder and self.num_maskmem > 0:\n            high_res_masks_for_mem_enc = high_res_masks\n            maskmem_features, maskmem_pos_enc = self._encode_new_memory(\n                current_vision_feats=current_vision_feats,\n                feat_sizes=feat_sizes,\n                pred_masks_high_res=high_res_masks_for_mem_enc,\n                object_score_logits=object_score_logits,\n                is_mask_from_pts=(point_inputs is not None),\n            )\n            current_out["maskmem_features"] = maskmem_features\n            current_out["maskmem_pos_enc"] = maskmem_pos_enc\n        else:\n            current_out["maskmem_features"] = None\n            current_out["maskmem_pos_enc"] = None\n\n    def track_step(\n        self,\n        frame_idx,\n        is_init_cond_frame,\n        current_vision_feats,\n        current_vision_pos_embeds,\n        feat_sizes,\n        point_inputs,\n        mask_inputs,\n        output_dict,\n        num_frames,\n        track_in_reverse=False,  # tracking in reverse time order (for demo usage)\n        # Whether to run the memory encoder on the predicted masks. Sometimes we might want\n        # to skip the memory encoder with `run_mem_encoder=False`. For example,\n        # in demo we might call `track_step` multiple times for each user click,\n        # and only encode the memory when the user finalizes their clicks. And in ablation\n        # settings like SAM training on static images, we don\'t need the memory encoder.\n        run_mem_encoder=True,\n        # The previously predicted SAM mask logits (which can be fed together with new clicks in demo).\n        prev_sam_mask_logits=None,\n    ):\n        current_out, sam_outputs, _, _ = self._track_step(\n            frame_idx,\n            is_init_cond_frame,\n            current_vision_feats,\n            current_vision_pos_embeds,\n            feat_sizes,\n            point_inputs,\n            mask_inputs,\n            output_dict,\n            num_frames,\n            track_in_reverse,\n            prev_sam_mask_logits,\n        )\n\n        (\n            _,\n            _,\n            _,\n            low_res_masks,\n            high_res_masks,\n            obj_ptr,\n            object_score_logits,\n        ) = sam_outputs\n\n        current_out["pred_masks"] = low_res_masks\n        current_out["pred_masks_high_res"] = high_res_masks\n        current_out["obj_ptr"] = obj_ptr\n        if not self.training:\n            # Only add this in inference (to avoid unused param in activation checkpointing;\n            # it\'s mainly used in the demo to encode spatial memories w/ consolidated masks)\n            current_out["object_score_logits"] = object_score_logits\n\n        # Finally run the memory encoder on the predicted mask to encode\n        # it into a new memory feature (that can be used in future frames)\n        self._encode_memory_in_output(\n            current_vision_feats,\n            feat_sizes,\n            point_inputs,\n            run_mem_encoder,\n            high_res_masks,\n            object_score_logits,\n            current_out,\n        )\n\n        return current_out\n\n    def _use_multimask(self, is_init_cond_frame, point_inputs):\n        """Whether to use multimask output in the SAM head."""\n        num_pts = 0 if point_inputs is None else point_inputs["point_labels"].size(1)\n        multimask_output = (\n            self.multimask_output_in_sam\n            and (is_init_cond_frame or self.multimask_output_for_tracking)\n            and (self.multimask_min_pt_num <= num_pts <= self.multimask_max_pt_num)\n        )\n        return multimask_output\n\n    def _apply_non_overlapping_constraints(self, pred_masks):\n        """\n        Apply non-overlapping constraints to the object scores in pred_masks. Here we\n        keep only the highest scoring object at each spatial location in pred_masks.\n        """\n        batch_size = pred_masks.size(0)\n        if batch_size == 1:\n            return pred_masks\n\n        device = pred_masks.device\n        # "max_obj_inds": object index of the object with the highest score at each location\n        max_obj_inds = torch.argmax(pred_masks, dim=0, keepdim=True)\n        # "batch_obj_inds": object index of each object slice (along dim 0) in `pred_masks`\n        batch_obj_inds = torch.arange(batch_size, device=device)[:, None, None, None]\n        keep = max_obj_inds == batch_obj_inds\n        # suppress overlapping regions\' scores below -10.0 so that the foreground regions\n        # don\'t overlap (here sigmoid(-10.0)=4.5398e-05)\n        pred_masks = torch.where(keep, pred_masks, torch.clamp(pred_masks, max=-10.0))\n        return pred_masks\n',
    'sam2.modeling.sam2_utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport copy\nfrom typing import Tuple\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom sam2.utils.misc import mask_to_box\n\n\ndef select_closest_cond_frames(frame_idx, cond_frame_outputs, max_cond_frame_num):\n    """\n    Select up to `max_cond_frame_num` conditioning frames from `cond_frame_outputs`\n    that are temporally closest to the current frame at `frame_idx`. Here, we take\n    - a) the closest conditioning frame before `frame_idx` (if any);\n    - b) the closest conditioning frame after `frame_idx` (if any);\n    - c) any other temporally closest conditioning frames until reaching a total\n         of `max_cond_frame_num` conditioning frames.\n\n    Outputs:\n    - selected_outputs: selected items (keys & values) from `cond_frame_outputs`.\n    - unselected_outputs: items (keys & values) not selected in `cond_frame_outputs`.\n    """\n    if max_cond_frame_num == -1 or len(cond_frame_outputs) <= max_cond_frame_num:\n        selected_outputs = cond_frame_outputs\n        unselected_outputs = {}\n    else:\n        assert max_cond_frame_num >= 2, "we should allow using 2+ conditioning frames"\n        selected_outputs = {}\n\n        # the closest conditioning frame before `frame_idx` (if any)\n        idx_before = max((t for t in cond_frame_outputs if t < frame_idx), default=None)\n        if idx_before is not None:\n            selected_outputs[idx_before] = cond_frame_outputs[idx_before]\n\n        # the closest conditioning frame after `frame_idx` (if any)\n        idx_after = min((t for t in cond_frame_outputs if t >= frame_idx), default=None)\n        if idx_after is not None:\n            selected_outputs[idx_after] = cond_frame_outputs[idx_after]\n\n        # add other temporally closest conditioning frames until reaching a total\n        # of `max_cond_frame_num` conditioning frames.\n        num_remain = max_cond_frame_num - len(selected_outputs)\n        inds_remain = sorted(\n            (t for t in cond_frame_outputs if t not in selected_outputs),\n            key=lambda x: abs(x - frame_idx),\n        )[:num_remain]\n        selected_outputs.update((t, cond_frame_outputs[t]) for t in inds_remain)\n        unselected_outputs = {\n            t: v for t, v in cond_frame_outputs.items() if t not in selected_outputs\n        }\n\n    return selected_outputs, unselected_outputs\n\n\ndef get_1d_sine_pe(pos_inds, dim, temperature=10000):\n    """\n    Get 1D sine positional embedding as in the original Transformer paper.\n    """\n    pe_dim = dim // 2\n    dim_t = torch.arange(pe_dim, dtype=torch.float32, device=pos_inds.device)\n    dim_t = temperature ** (2 * (dim_t // 2) / pe_dim)\n\n    pos_embed = pos_inds.unsqueeze(-1) / dim_t\n    pos_embed = torch.cat([pos_embed.sin(), pos_embed.cos()], dim=-1)\n    return pos_embed\n\n\ndef get_activation_fn(activation):\n    """Return an activation function given a string"""\n    if activation == "relu":\n        return F.relu\n    if activation == "gelu":\n        return F.gelu\n    if activation == "glu":\n        return F.glu\n    raise RuntimeError(f"activation should be relu/gelu, not {activation}.")\n\n\ndef get_clones(module, N):\n    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])\n\n\nclass DropPath(nn.Module):\n    # adapted from https://github.com/huggingface/pytorch-image-models/blob/main/timm/layers/drop.py\n    def __init__(self, drop_prob=0.0, scale_by_keep=True):\n        super(DropPath, self).__init__()\n        self.drop_prob = drop_prob\n        self.scale_by_keep = scale_by_keep\n\n    def forward(self, x):\n        if self.drop_prob == 0.0 or not self.training:\n            return x\n        keep_prob = 1 - self.drop_prob\n        shape = (x.shape[0],) + (1,) * (x.ndim - 1)\n        random_tensor = x.new_empty(shape).bernoulli_(keep_prob)\n        if keep_prob > 0.0 and self.scale_by_keep:\n            random_tensor.div_(keep_prob)\n        return x * random_tensor\n\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        activation: nn.Module = nn.ReLU,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n        self.act = activation()\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = self.act(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x\n\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x\n\n\ndef sample_box_points(\n    masks: torch.Tensor,\n    noise: float = 0.1,  # SAM default\n    noise_bound: int = 20,  # SAM default\n    top_left_label: int = 2,\n    bottom_right_label: int = 3,\n) -> Tuple[np.array, np.array]:\n    """\n    Sample a noised version of the top left and bottom right corners of a given `bbox`\n\n    Inputs:\n    - masks: [B, 1, H,W] boxes, dtype=torch.Tensor\n    - noise: noise as a fraction of box width and height, dtype=float\n    - noise_bound: maximum amount of noise (in pure pixesl), dtype=int\n\n    Returns:\n    - box_coords: [B, num_pt, 2], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.float\n    - box_labels: [B, num_pt], label 2 is reserverd for top left and 3 for bottom right corners, dtype=torch.int32\n    """\n    device = masks.device\n    box_coords = mask_to_box(masks)\n    B, _, H, W = masks.shape\n    box_labels = torch.tensor(\n        [top_left_label, bottom_right_label], dtype=torch.int, device=device\n    ).repeat(B)\n    if noise > 0.0:\n        if not isinstance(noise_bound, torch.Tensor):\n            noise_bound = torch.tensor(noise_bound, device=device)\n        bbox_w = box_coords[..., 2] - box_coords[..., 0]\n        bbox_h = box_coords[..., 3] - box_coords[..., 1]\n        max_dx = torch.min(bbox_w * noise, noise_bound)\n        max_dy = torch.min(bbox_h * noise, noise_bound)\n        box_noise = 2 * torch.rand(B, 1, 4, device=device) - 1\n        box_noise = box_noise * torch.stack((max_dx, max_dy, max_dx, max_dy), dim=-1)\n\n        box_coords = box_coords + box_noise\n        img_bounds = (\n            torch.tensor([W, H, W, H], device=device) - 1\n        )  # uncentered pixel coords\n        box_coords.clamp_(torch.zeros_like(img_bounds), img_bounds)  # In place clamping\n\n    box_coords = box_coords.reshape(-1, 2, 2)  # always 2 points\n    box_labels = box_labels.reshape(-1, 2)\n    return box_coords, box_labels\n\n\ndef sample_random_points_from_errors(gt_masks, pred_masks, num_pt=1):\n    """\n    Sample `num_pt` random points (along with their labels) independently from the error regions.\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - num_pt: int, number of points to sample independently for each of the B error maps\n\n    Outputs:\n    - points: [B, num_pt, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, num_pt], dtype=torch.int32, where 1 means positive clicks and 0 means\n      negative clicks\n    """\n    if pred_masks is None:  # if pred_masks is not provided, treat it as empty\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n    assert num_pt >= 0\n\n    B, _, H_im, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n    # whether the prediction completely match the ground-truth on each mask\n    all_correct = torch.all((gt_masks == pred_masks).flatten(2), dim=2)\n    all_correct = all_correct[..., None, None]\n\n    # channel 0 is FP map, while channel 1 is FN map\n    pts_noise = torch.rand(B, num_pt, H_im, W_im, 2, device=device)\n    # sample a negative new click from FP region or a positive new click\n    # from FN region, depend on where the maximum falls,\n    # and in case the predictions are all correct (no FP or FN), we just\n    # sample a negative click from the background region\n    pts_noise[..., 0] *= fp_masks | (all_correct & ~gt_masks)\n    pts_noise[..., 1] *= fn_masks\n    pts_idx = pts_noise.flatten(2).argmax(dim=2)\n    labels = (pts_idx % 2).to(torch.int32)\n    pts_idx = pts_idx // 2\n    pts_x = pts_idx % W_im\n    pts_y = pts_idx // W_im\n    points = torch.stack([pts_x, pts_y], dim=2).to(torch.float)\n    return points, labels\n\n\ndef sample_one_point_from_error_center(gt_masks, pred_masks, padding=True):\n    """\n    Sample 1 random point (along with its label) from the center of each error region,\n    that is, the point with the largest distance to the boundary of each error region.\n    This is the RITM sampling method from https://github.com/saic-vul/ritm_interactive_segmentation/blob/master/isegm/inference/clicker.py\n\n    Inputs:\n    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool\n    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None\n    - padding: if True, pad with boundary of 1 px for distance transform\n\n    Outputs:\n    - points: [B, 1, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point\n    - labels: [B, 1], dtype=torch.int32, where 1 means positive clicks and 0 means negative clicks\n    """\n    import cv2\n\n    if pred_masks is None:\n        pred_masks = torch.zeros_like(gt_masks)\n    assert gt_masks.dtype == torch.bool and gt_masks.size(1) == 1\n    assert pred_masks.dtype == torch.bool and pred_masks.shape == gt_masks.shape\n\n    B, _, _, W_im = gt_masks.shape\n    device = gt_masks.device\n\n    # false positive region, a new point sampled in this region should have\n    # negative label to correct the FP error\n    fp_masks = ~gt_masks & pred_masks\n    # false negative region, a new point sampled in this region should have\n    # positive label to correct the FN error\n    fn_masks = gt_masks & ~pred_masks\n\n    fp_masks = fp_masks.cpu().numpy()\n    fn_masks = fn_masks.cpu().numpy()\n    points = torch.zeros(B, 1, 2, dtype=torch.float)\n    labels = torch.ones(B, 1, dtype=torch.int32)\n    for b in range(B):\n        fn_mask = fn_masks[b, 0]\n        fp_mask = fp_masks[b, 0]\n        if padding:\n            fn_mask = np.pad(fn_mask, ((1, 1), (1, 1)), "constant")\n            fp_mask = np.pad(fp_mask, ((1, 1), (1, 1)), "constant")\n        # compute the distance of each point in FN/FP region to its boundary\n        fn_mask_dt = cv2.distanceTransform(fn_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        fp_mask_dt = cv2.distanceTransform(fp_mask.astype(np.uint8), cv2.DIST_L2, 0)\n        if padding:\n            fn_mask_dt = fn_mask_dt[1:-1, 1:-1]\n            fp_mask_dt = fp_mask_dt[1:-1, 1:-1]\n\n        # take the point in FN/FP region with the largest distance to its boundary\n        fn_mask_dt_flat = fn_mask_dt.reshape(-1)\n        fp_mask_dt_flat = fp_mask_dt.reshape(-1)\n        fn_argmax = np.argmax(fn_mask_dt_flat)\n        fp_argmax = np.argmax(fp_mask_dt_flat)\n        is_positive = fn_mask_dt_flat[fn_argmax] > fp_mask_dt_flat[fp_argmax]\n        pt_idx = fn_argmax if is_positive else fp_argmax\n        points[b, 0, 0] = pt_idx % W_im  # x\n        points[b, 0, 1] = pt_idx // W_im  # y\n        labels[b, 0] = int(is_positive)\n\n    points = points.to(device)\n    labels = labels.to(device)\n    return points, labels\n\n\ndef get_next_point(gt_masks, pred_masks, method):\n    if method == "uniform":\n        return sample_random_points_from_errors(gt_masks, pred_masks)\n    elif method == "center":\n        return sample_one_point_from_error_center(gt_masks, pred_masks)\n    else:\n        raise ValueError(f"unknown sampling method {method}")\n',
    'sam2.sam2_video_predictor_npz': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport warnings\nfrom collections import OrderedDict\n\nimport torch\n\nfrom tqdm import tqdm\n\nfrom sam2.modeling.sam2_base import NO_OBJ_SCORE, SAM2Base\nfrom sam2.utils.misc import concat_points, fill_holes_in_mask_scores, load_video_frames\n\n\nclass SAM2VideoPredictorNPZ(SAM2Base):\n    """The predictor class to handle user interactions and manage inference states."""\n\n    def __init__(\n        self,\n        fill_hole_area=0,\n        # whether to apply non-overlapping constraints on the output object masks\n        non_overlap_masks=False,\n        # whether to clear non-conditioning memory of the surrounding frames (which may contain outdated information) after adding correction clicks;\n        # note that this would only apply to *single-object tracking* unless `clear_non_cond_mem_for_multi_obj` is also set to True)\n        clear_non_cond_mem_around_input=False,\n        # whether to also clear non-conditioning memory of the surrounding frames (only effective when `clear_non_cond_mem_around_input` is True).\n        clear_non_cond_mem_for_multi_obj=False,\n        # if `add_all_frames_to_correct_as_cond` is True, we also append to the conditioning frame list any frame that receives a later correction click\n        # if `add_all_frames_to_correct_as_cond` is False, we conditioning frame list to only use those initial conditioning frames\n        add_all_frames_to_correct_as_cond=False,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.fill_hole_area = fill_hole_area\n        self.non_overlap_masks = non_overlap_masks\n        self.clear_non_cond_mem_around_input = clear_non_cond_mem_around_input\n        self.clear_non_cond_mem_for_multi_obj = clear_non_cond_mem_for_multi_obj\n        self.add_all_frames_to_correct_as_cond = add_all_frames_to_correct_as_cond\n\n    @torch.inference_mode()\n    def init_state(\n        self,\n        #video_path,\n        # added below\n        images,\n        video_height,\n        video_width,\n        offload_video_to_cpu=False,\n        offload_state_to_cpu=False,\n        async_loading_frames=False,\n    ):\n        """Initialize an inference state."""\n        compute_device = self.device  # device of the model\n        # images, video_height, video_width = load_video_frames(\n        #     video_path=video_path,\n        #     image_size=self.image_size,\n        #     offload_video_to_cpu=offload_video_to_cpu,\n        #     async_loading_frames=async_loading_frames,\n        #     compute_device=compute_device,\n        # )\n        inference_state = {}\n        inference_state["images"] = images\n        inference_state["num_frames"] = len(images)\n        # whether to offload the video frames to CPU memory\n        # turning on this option saves the GPU memory with only a very small overhead\n        inference_state["offload_video_to_cpu"] = offload_video_to_cpu\n        # whether to offload the inference state to CPU memory\n        # turning on this option saves the GPU memory at the cost of a lower tracking fps\n        # (e.g. in a test case of 768x768 model, fps dropped from 27 to 24 when tracking one object\n        # and from 24 to 21 when tracking two objects)\n        inference_state["offload_state_to_cpu"] = offload_state_to_cpu\n        # the original video height and width, used for resizing final output scores\n        inference_state["video_height"] = video_height\n        inference_state["video_width"] = video_width\n        inference_state["device"] = compute_device\n        if offload_state_to_cpu:\n            inference_state["storage_device"] = torch.device("cpu")\n        else:\n            inference_state["storage_device"] = compute_device\n        # inputs on each frame\n        inference_state["point_inputs_per_obj"] = {}\n        inference_state["mask_inputs_per_obj"] = {}\n        # visual features on a small number of recently visited frames for quick interactions\n        inference_state["cached_features"] = {}\n        # values that don\'t change across frames (so we only need to hold one copy of them)\n        inference_state["constants"] = {}\n        # mapping between client-side object id and model-side object index\n        inference_state["obj_id_to_idx"] = OrderedDict()\n        inference_state["obj_idx_to_id"] = OrderedDict()\n        inference_state["obj_ids"] = []\n        # A storage to hold the model\'s tracking results and states on each frame\n        inference_state["output_dict"] = {\n            "cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n            "non_cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n        }\n        # Slice (view) of each object tracking results, sharing the same memory with "output_dict"\n        inference_state["output_dict_per_obj"] = {}\n        # A temporary storage to hold new outputs when user interact with a frame\n        # to add clicks or mask (it\'s merged into "output_dict" before propagation starts)\n        inference_state["temp_output_dict_per_obj"] = {}\n        # Frames that already holds consolidated outputs from click or mask inputs\n        # (we directly use their consolidated outputs during tracking)\n        inference_state["consolidated_frame_inds"] = {\n            "cond_frame_outputs": set(),  # set containing frame indices\n            "non_cond_frame_outputs": set(),  # set containing frame indices\n        }\n        # metadata for each tracking frame (e.g. which direction it\'s tracked)\n        inference_state["tracking_has_started"] = False\n        inference_state["frames_already_tracked"] = {}\n        # Warm up the visual backbone and cache the image feature on frame 0\n        self._get_image_feature(inference_state, frame_idx=0, batch_size=1)\n        return inference_state\n\n    @classmethod\n    def from_pretrained(cls, model_id: str, **kwargs) -> "SAM2VideoPredictor":\n        """\n        Load a pretrained model from the Hugging Face hub.\n\n        Arguments:\n          model_id (str): The Hugging Face repository ID.\n          **kwargs: Additional arguments to pass to the model constructor.\n\n        Returns:\n          (SAM2VideoPredictor): The loaded model.\n        """\n        from sam2.build_sam import build_sam2_video_predictor_hf\n\n        sam_model = build_sam2_video_predictor_hf(model_id, **kwargs)\n        return sam_model\n\n    def _obj_id_to_idx(self, inference_state, obj_id):\n        """Map client-side object id to model-side object index."""\n        obj_idx = inference_state["obj_id_to_idx"].get(obj_id, None)\n        if obj_idx is not None:\n            return obj_idx\n\n        # This is a new object id not sent to the server before. We only allow adding\n        # new objects *before* the tracking starts.\n        allow_new_object = not inference_state["tracking_has_started"]\n        if allow_new_object:\n            # get the next object slot\n            obj_idx = len(inference_state["obj_id_to_idx"])\n            inference_state["obj_id_to_idx"][obj_id] = obj_idx\n            inference_state["obj_idx_to_id"][obj_idx] = obj_id\n            inference_state["obj_ids"] = list(inference_state["obj_id_to_idx"])\n            # set up input and output structures for this object\n            inference_state["point_inputs_per_obj"][obj_idx] = {}\n            inference_state["mask_inputs_per_obj"][obj_idx] = {}\n            inference_state["output_dict_per_obj"][obj_idx] = {\n                "cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n                "non_cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n            }\n            inference_state["temp_output_dict_per_obj"][obj_idx] = {\n                "cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n                "non_cond_frame_outputs": {},  # dict containing {frame_idx: <out>}\n            }\n            return obj_idx\n        else:\n            raise RuntimeError(\n                f"Cannot add new object id {obj_id} after tracking starts. "\n                f"All existing object ids: {inference_state[\'obj_ids\']}. "\n                f"Please call \'reset_state\' to restart from scratch."\n            )\n\n    def _obj_idx_to_id(self, inference_state, obj_idx):\n        """Map model-side object index to client-side object id."""\n        return inference_state["obj_idx_to_id"][obj_idx]\n\n    def _get_obj_num(self, inference_state):\n        """Get the total number of unique object ids received so far in this session."""\n        return len(inference_state["obj_idx_to_id"])\n\n    @torch.inference_mode()\n    def add_new_points_or_box(\n        self,\n        inference_state,\n        frame_idx,\n        obj_id,\n        points=None,\n        labels=None,\n        clear_old_points=True,\n        normalize_coords=True,\n        box=None,\n    ):\n        """Add new points to a frame."""\n        obj_idx = self._obj_id_to_idx(inference_state, obj_id)\n        point_inputs_per_frame = inference_state["point_inputs_per_obj"][obj_idx]\n        mask_inputs_per_frame = inference_state["mask_inputs_per_obj"][obj_idx]\n\n        if (points is not None) != (labels is not None):\n            raise ValueError("points and labels must be provided together")\n        if points is None and box is None:\n            raise ValueError("at least one of points or box must be provided as input")\n\n        if points is None:\n            points = torch.zeros(0, 2, dtype=torch.float32)\n        elif not isinstance(points, torch.Tensor):\n            points = torch.tensor(points, dtype=torch.float32)\n        if labels is None:\n            labels = torch.zeros(0, dtype=torch.int32)\n        elif not isinstance(labels, torch.Tensor):\n            labels = torch.tensor(labels, dtype=torch.int32)\n        if points.dim() == 2:\n            points = points.unsqueeze(0)  # add batch dimension\n        if labels.dim() == 1:\n            labels = labels.unsqueeze(0)  # add batch dimension\n\n        # If `box` is provided, we add it as the first two points with labels 2 and 3\n        # along with the user-provided points (consistent with how SAM 2 is trained).\n        if box is not None:\n            if not clear_old_points:\n                raise ValueError(\n                    "cannot add box without clearing old points, since "\n                    "box prompt must be provided before any point prompt "\n                    "(please use clear_old_points=True instead)"\n                )\n            if inference_state["tracking_has_started"]:\n                warnings.warn(\n                    "You are adding a box after tracking starts. SAM 2 may not always be "\n                    "able to incorporate a box prompt for *refinement*. If you intend to "\n                    "use box prompt as an *initial* input before tracking, please call "\n                    "\'reset_state\' on the inference state to restart from scratch.",\n                    category=UserWarning,\n                    stacklevel=2,\n                )\n            if not isinstance(box, torch.Tensor):\n                box = torch.tensor(box, dtype=torch.float32, device=points.device)\n            box_coords = box.reshape(1, 2, 2)\n            box_labels = torch.tensor([2, 3], dtype=torch.int32, device=labels.device)\n            box_labels = box_labels.reshape(1, 2)\n            points = torch.cat([box_coords, points], dim=1)\n            labels = torch.cat([box_labels, labels], dim=1)\n\n        if normalize_coords:\n            video_H = inference_state["video_height"]\n            video_W = inference_state["video_width"]\n            points = points / torch.tensor([video_W, video_H]).to(points.device)\n        # scale the (normalized) coordinates by the model\'s internal image size\n        points = points * self.image_size\n        points = points.to(inference_state["device"])\n        labels = labels.to(inference_state["device"])\n\n        if not clear_old_points:\n            point_inputs = point_inputs_per_frame.get(frame_idx, None)\n        else:\n            point_inputs = None\n        point_inputs = concat_points(point_inputs, points, labels)\n\n        point_inputs_per_frame[frame_idx] = point_inputs\n        mask_inputs_per_frame.pop(frame_idx, None)\n        # If this frame hasn\'t been tracked before, we treat it as an initial conditioning\n        # frame, meaning that the inputs points are to generate segments on this frame without\n        # using any memory from other frames, like in SAM. Otherwise (if it has been tracked),\n        # the input points will be used to correct the already tracked masks.\n        is_init_cond_frame = frame_idx not in inference_state["frames_already_tracked"]\n        # whether to track in reverse time order\n        if is_init_cond_frame:\n            reverse = False\n        else:\n            reverse = inference_state["frames_already_tracked"][frame_idx]["reverse"]\n        obj_output_dict = inference_state["output_dict_per_obj"][obj_idx]\n        obj_temp_output_dict = inference_state["temp_output_dict_per_obj"][obj_idx]\n        # Add a frame to conditioning output if it\'s an initial conditioning frame or\n        # if the model sees all frames receiving clicks/mask as conditioning frames.\n        is_cond = is_init_cond_frame or self.add_all_frames_to_correct_as_cond\n        storage_key = "cond_frame_outputs" if is_cond else "non_cond_frame_outputs"\n\n        # Get any previously predicted mask logits on this object and feed it along with\n        # the new clicks into the SAM mask decoder.\n        prev_sam_mask_logits = None\n        # lookup temporary output dict first, which contains the most recent output\n        # (if not found, then lookup conditioning and non-conditioning frame output)\n        prev_out = obj_temp_output_dict[storage_key].get(frame_idx)\n        if prev_out is None:\n            prev_out = obj_output_dict["cond_frame_outputs"].get(frame_idx)\n            if prev_out is None:\n                prev_out = obj_output_dict["non_cond_frame_outputs"].get(frame_idx)\n\n        if prev_out is not None and prev_out["pred_masks"] is not None:\n            device = inference_state["device"]\n            prev_sam_mask_logits = prev_out["pred_masks"].to(device, non_blocking=True)\n            # Clamp the scale of prev_sam_mask_logits to avoid rare numerical issues.\n            prev_sam_mask_logits = torch.clamp(prev_sam_mask_logits, -32.0, 32.0)\n        current_out, _ = self._run_single_frame_inference(\n            inference_state=inference_state,\n            output_dict=obj_output_dict,  # run on the slice of a single object\n            frame_idx=frame_idx,\n            batch_size=1,  # run on the slice of a single object\n            is_init_cond_frame=is_init_cond_frame,\n            point_inputs=point_inputs,\n            mask_inputs=None,\n            reverse=reverse,\n            # Skip the memory encoder when adding clicks or mask. We execute the memory encoder\n            # at the beginning of `propagate_in_video` (after user finalize their clicks). This\n            # allows us to enforce non-overlapping constraints on all objects before encoding\n            # them into memory.\n            run_mem_encoder=False,\n            prev_sam_mask_logits=prev_sam_mask_logits,\n        )\n        # Add the output to the output dict (to be used as future memory)\n        obj_temp_output_dict[storage_key][frame_idx] = current_out\n\n        # Resize the output mask to the original video resolution\n        obj_ids = inference_state["obj_ids"]\n        consolidated_out = self._consolidate_temp_output_across_obj(\n            inference_state,\n            frame_idx,\n            is_cond=is_cond,\n            run_mem_encoder=False,\n            consolidate_at_video_res=True,\n        )\n        _, video_res_masks = self._get_orig_video_res_output(\n            inference_state, consolidated_out["pred_masks_video_res"]\n        )\n        return frame_idx, obj_ids, video_res_masks\n\n    def add_new_points(self, *args, **kwargs):\n        """Deprecated method. Please use `add_new_points_or_box` instead."""\n        return self.add_new_points_or_box(*args, **kwargs)\n\n    @torch.inference_mode()\n    def add_new_mask(\n        self,\n        inference_state,\n        frame_idx,\n        obj_id,\n        mask,\n    ):\n        """Add new mask to a frame."""\n        obj_idx = self._obj_id_to_idx(inference_state, obj_id)\n        point_inputs_per_frame = inference_state["point_inputs_per_obj"][obj_idx]\n        mask_inputs_per_frame = inference_state["mask_inputs_per_obj"][obj_idx]\n\n        if not isinstance(mask, torch.Tensor):\n            mask = torch.tensor(mask, dtype=torch.bool)\n        assert mask.dim() == 2\n        mask_H, mask_W = mask.shape\n        mask_inputs_orig = mask[None, None]  # add batch and channel dimension\n        mask_inputs_orig = mask_inputs_orig.float().to(inference_state["device"])\n\n        # resize the mask if it doesn\'t match the model\'s image size\n        if mask_H != self.image_size or mask_W != self.image_size:\n            mask_inputs = torch.nn.functional.interpolate(\n                mask_inputs_orig,\n                size=(self.image_size, self.image_size),\n                align_corners=False,\n                mode="bilinear",\n                antialias=True,  # use antialias for downsampling\n            )\n            mask_inputs = (mask_inputs >= 0.5).float()\n        else:\n            mask_inputs = mask_inputs_orig\n\n        mask_inputs_per_frame[frame_idx] = mask_inputs\n        point_inputs_per_frame.pop(frame_idx, None)\n        # If this frame hasn\'t been tracked before, we treat it as an initial conditioning\n        # frame, meaning that the inputs points are to generate segments on this frame without\n        # using any memory from other frames, like in SAM. Otherwise (if it has been tracked),\n        # the input points will be used to correct the already tracked masks.\n        is_init_cond_frame = frame_idx not in inference_state["frames_already_tracked"]\n        # whether to track in reverse time order\n        if is_init_cond_frame:\n            reverse = False\n        else:\n            reverse = inference_state["frames_already_tracked"][frame_idx]["reverse"]\n        obj_output_dict = inference_state["output_dict_per_obj"][obj_idx]\n        obj_temp_output_dict = inference_state["temp_output_dict_per_obj"][obj_idx]\n        # Add a frame to conditioning output if it\'s an initial conditioning frame or\n        # if the model sees all frames receiving clicks/mask as conditioning frames.\n        is_cond = is_init_cond_frame or self.add_all_frames_to_correct_as_cond\n        storage_key = "cond_frame_outputs" if is_cond else "non_cond_frame_outputs"\n\n        current_out, _ = self._run_single_frame_inference(\n            inference_state=inference_state,\n            output_dict=obj_output_dict,  # run on the slice of a single object\n            frame_idx=frame_idx,\n            batch_size=1,  # run on the slice of a single object\n            is_init_cond_frame=is_init_cond_frame,\n            point_inputs=None,\n            mask_inputs=mask_inputs,\n            reverse=reverse,\n            # Skip the memory encoder when adding clicks or mask. We execute the memory encoder\n            # at the beginning of `propagate_in_video` (after user finalize their clicks). This\n            # allows us to enforce non-overlapping constraints on all objects before encoding\n            # them into memory.\n            run_mem_encoder=False,\n        )\n        # Add the output to the output dict (to be used as future memory)\n        obj_temp_output_dict[storage_key][frame_idx] = current_out\n\n        # Resize the output mask to the original video resolution\n        obj_ids = inference_state["obj_ids"]\n        consolidated_out = self._consolidate_temp_output_across_obj(\n            inference_state,\n            frame_idx,\n            is_cond=is_cond,\n            run_mem_encoder=False,\n            consolidate_at_video_res=True,\n        )\n        _, video_res_masks = self._get_orig_video_res_output(\n            inference_state, consolidated_out["pred_masks_video_res"]\n        )\n        return frame_idx, obj_ids, video_res_masks\n\n    def _get_orig_video_res_output(self, inference_state, any_res_masks):\n        """\n        Resize the object scores to the original video resolution (video_res_masks)\n        and apply non-overlapping constraints for final output.\n        """\n        device = inference_state["device"]\n        video_H = inference_state["video_height"]\n        video_W = inference_state["video_width"]\n        any_res_masks = any_res_masks.to(device, non_blocking=True)\n        if any_res_masks.shape[-2:] == (video_H, video_W):\n            video_res_masks = any_res_masks\n        else:\n            video_res_masks = torch.nn.functional.interpolate(\n                any_res_masks,\n                size=(video_H, video_W),\n                mode="bilinear",\n                align_corners=False,\n            )\n        if self.non_overlap_masks:\n            video_res_masks = self._apply_non_overlapping_constraints(video_res_masks)\n        return any_res_masks, video_res_masks\n\n    def _consolidate_temp_output_across_obj(\n        self,\n        inference_state,\n        frame_idx,\n        is_cond,\n        run_mem_encoder,\n        consolidate_at_video_res=False,\n    ):\n        """\n        Consolidate the per-object temporary outputs in `temp_output_dict_per_obj` on\n        a frame into a single output for all objects, including\n        1) fill any missing objects either from `output_dict_per_obj` (if they exist in\n           `output_dict_per_obj` for this frame) or leave them as placeholder values\n           (if they don\'t exist in `output_dict_per_obj` for this frame);\n        2) if specified, rerun memory encoder after apply non-overlapping constraints\n           on the object scores.\n        """\n        batch_size = self._get_obj_num(inference_state)\n        storage_key = "cond_frame_outputs" if is_cond else "non_cond_frame_outputs"\n        # Optionally, we allow consolidating the temporary outputs at the original\n        # video resolution (to provide a better editing experience for mask prompts).\n        if consolidate_at_video_res:\n            assert not run_mem_encoder, "memory encoder cannot run at video resolution"\n            consolidated_H = inference_state["video_height"]\n            consolidated_W = inference_state["video_width"]\n            consolidated_mask_key = "pred_masks_video_res"\n        else:\n            consolidated_H = consolidated_W = self.image_size // 4\n            consolidated_mask_key = "pred_masks"\n\n        # Initialize `consolidated_out`. Its "maskmem_features" and "maskmem_pos_enc"\n        # will be added when rerunning the memory encoder after applying non-overlapping\n        # constraints to object scores. Its "pred_masks" are prefilled with a large\n        # negative value (NO_OBJ_SCORE) to represent missing objects.\n        consolidated_out = {\n            "maskmem_features": None,\n            "maskmem_pos_enc": None,\n            consolidated_mask_key: torch.full(\n                size=(batch_size, 1, consolidated_H, consolidated_W),\n                fill_value=NO_OBJ_SCORE,\n                dtype=torch.float32,\n                device=inference_state["storage_device"],\n            ),\n            "obj_ptr": torch.full(\n                size=(batch_size, self.hidden_dim),\n                fill_value=NO_OBJ_SCORE,\n                dtype=torch.float32,\n                device=inference_state["device"],\n            ),\n            "object_score_logits": torch.full(\n                size=(batch_size, 1),\n                # default to 10.0 for object_score_logits, i.e. assuming the object is\n                # present as sigmoid(10)=1, same as in `predict_masks` of `MaskDecoder`\n                fill_value=10.0,\n                dtype=torch.float32,\n                device=inference_state["device"],\n            ),\n        }\n        empty_mask_ptr = None\n        for obj_idx in range(batch_size):\n            obj_temp_output_dict = inference_state["temp_output_dict_per_obj"][obj_idx]\n            obj_output_dict = inference_state["output_dict_per_obj"][obj_idx]\n            out = obj_temp_output_dict[storage_key].get(frame_idx, None)\n            # If the object doesn\'t appear in "temp_output_dict_per_obj" on this frame,\n            # we fall back and look up its previous output in "output_dict_per_obj".\n            # We look up both "cond_frame_outputs" and "non_cond_frame_outputs" in\n            # "output_dict_per_obj" to find a previous output for this object.\n            if out is None:\n                out = obj_output_dict["cond_frame_outputs"].get(frame_idx, None)\n            if out is None:\n                out = obj_output_dict["non_cond_frame_outputs"].get(frame_idx, None)\n            # If the object doesn\'t appear in "output_dict_per_obj" either, we skip it\n            # and leave its mask scores to the default scores (i.e. the NO_OBJ_SCORE\n            # placeholder above) and set its object pointer to be a dummy pointer.\n            if out is None:\n                # Fill in dummy object pointers for those objects without any inputs or\n                # tracking outcomes on this frame (only do it under `run_mem_encoder=True`,\n                # i.e. when we need to build the memory for tracking).\n                if run_mem_encoder:\n                    if empty_mask_ptr is None:\n                        empty_mask_ptr = self._get_empty_mask_ptr(\n                            inference_state, frame_idx\n                        )\n                    # fill object pointer with a dummy pointer (based on an empty mask)\n                    consolidated_out["obj_ptr"][obj_idx : obj_idx + 1] = empty_mask_ptr\n                continue\n            # Add the temporary object output mask to consolidated output mask\n            obj_mask = out["pred_masks"]\n            consolidated_pred_masks = consolidated_out[consolidated_mask_key]\n            if obj_mask.shape[-2:] == consolidated_pred_masks.shape[-2:]:\n                consolidated_pred_masks[obj_idx : obj_idx + 1] = obj_mask\n            else:\n                # Resize first if temporary object mask has a different resolution\n                resized_obj_mask = torch.nn.functional.interpolate(\n                    obj_mask,\n                    size=consolidated_pred_masks.shape[-2:],\n                    mode="bilinear",\n                    align_corners=False,\n                )\n                consolidated_pred_masks[obj_idx : obj_idx + 1] = resized_obj_mask\n            consolidated_out["obj_ptr"][obj_idx : obj_idx + 1] = out["obj_ptr"]\n            consolidated_out["object_score_logits"][obj_idx : obj_idx + 1] = out[\n                "object_score_logits"\n            ]\n\n        # Optionally, apply non-overlapping constraints on the consolidated scores\n        # and rerun the memory encoder\n        if run_mem_encoder:\n            device = inference_state["device"]\n            high_res_masks = torch.nn.functional.interpolate(\n                consolidated_out["pred_masks"].to(device, non_blocking=True),\n                size=(self.image_size, self.image_size),\n                mode="bilinear",\n                align_corners=False,\n            )\n            if self.non_overlap_masks_for_mem_enc:\n                high_res_masks = self._apply_non_overlapping_constraints(high_res_masks)\n            maskmem_features, maskmem_pos_enc = self._run_memory_encoder(\n                inference_state=inference_state,\n                frame_idx=frame_idx,\n                batch_size=batch_size,\n                high_res_masks=high_res_masks,\n                object_score_logits=consolidated_out["object_score_logits"],\n                is_mask_from_pts=True,  # these frames are what the user interacted with\n            )\n            consolidated_out["maskmem_features"] = maskmem_features\n            consolidated_out["maskmem_pos_enc"] = maskmem_pos_enc\n\n        return consolidated_out\n\n    def _get_empty_mask_ptr(self, inference_state, frame_idx):\n        """Get a dummy object pointer based on an empty mask on the current frame."""\n        # A dummy (empty) mask with a single object\n        batch_size = 1\n        mask_inputs = torch.zeros(\n            (batch_size, 1, self.image_size, self.image_size),\n            dtype=torch.float32,\n            device=inference_state["device"],\n        )\n\n        # Retrieve correct image features\n        (\n            _,\n            _,\n            current_vision_feats,\n            current_vision_pos_embeds,\n            feat_sizes,\n        ) = self._get_image_feature(inference_state, frame_idx, batch_size)\n\n        # Feed the empty mask and image feature above to get a dummy object pointer\n        current_out = self.track_step(\n            frame_idx=frame_idx,\n            is_init_cond_frame=True,\n            current_vision_feats=current_vision_feats,\n            current_vision_pos_embeds=current_vision_pos_embeds,\n            feat_sizes=feat_sizes,\n            point_inputs=None,\n            mask_inputs=mask_inputs,\n            output_dict={},\n            num_frames=inference_state["num_frames"],\n            track_in_reverse=False,\n            run_mem_encoder=False,\n            prev_sam_mask_logits=None,\n        )\n        return current_out["obj_ptr"]\n\n    @torch.inference_mode()\n    def propagate_in_video_preflight(self, inference_state):\n        """Prepare inference_state and consolidate temporary outputs before tracking."""\n        # Tracking has started and we don\'t allow adding new objects until session is reset.\n        inference_state["tracking_has_started"] = True\n        batch_size = self._get_obj_num(inference_state)\n\n        # Consolidate per-object temporary outputs in "temp_output_dict_per_obj" and\n        # add them into "output_dict".\n        temp_output_dict_per_obj = inference_state["temp_output_dict_per_obj"]\n        output_dict = inference_state["output_dict"]\n        # "consolidated_frame_inds" contains indices of those frames where consolidated\n        # temporary outputs have been added (either in this call or any previous calls\n        # to `propagate_in_video_preflight`).\n        consolidated_frame_inds = inference_state["consolidated_frame_inds"]\n        for is_cond in [False, True]:\n            # Separately consolidate conditioning and non-conditioning temp outputs\n            storage_key = "cond_frame_outputs" if is_cond else "non_cond_frame_outputs"\n            # Find all the frames that contain temporary outputs for any objects\n            # (these should be the frames that have just received clicks for mask inputs\n            # via `add_new_points_or_box` or `add_new_mask`)\n            temp_frame_inds = set()\n            for obj_temp_output_dict in temp_output_dict_per_obj.values():\n                temp_frame_inds.update(obj_temp_output_dict[storage_key].keys())\n            consolidated_frame_inds[storage_key].update(temp_frame_inds)\n            # consolidate the temporary output across all objects on this frame\n            for frame_idx in temp_frame_inds:\n                consolidated_out = self._consolidate_temp_output_across_obj(\n                    inference_state, frame_idx, is_cond=is_cond, run_mem_encoder=True\n                )\n                # merge them into "output_dict" and also create per-object slices\n                output_dict[storage_key][frame_idx] = consolidated_out\n                self._add_output_per_object(\n                    inference_state, frame_idx, consolidated_out, storage_key\n                )\n                clear_non_cond_mem = self.clear_non_cond_mem_around_input and (\n                    self.clear_non_cond_mem_for_multi_obj or batch_size <= 1\n                )\n                if clear_non_cond_mem:\n                    # clear non-conditioning memory of the surrounding frames\n                    self._clear_non_cond_mem_around_input(inference_state, frame_idx)\n\n            # clear temporary outputs in `temp_output_dict_per_obj`\n            for obj_temp_output_dict in temp_output_dict_per_obj.values():\n                obj_temp_output_dict[storage_key].clear()\n\n        # edge case: if an output is added to "cond_frame_outputs", we remove any prior\n        # output on the same frame in "non_cond_frame_outputs"\n        for frame_idx in output_dict["cond_frame_outputs"]:\n            output_dict["non_cond_frame_outputs"].pop(frame_idx, None)\n        for obj_output_dict in inference_state["output_dict_per_obj"].values():\n            for frame_idx in obj_output_dict["cond_frame_outputs"]:\n                obj_output_dict["non_cond_frame_outputs"].pop(frame_idx, None)\n        for frame_idx in consolidated_frame_inds["cond_frame_outputs"]:\n            assert frame_idx in output_dict["cond_frame_outputs"]\n            consolidated_frame_inds["non_cond_frame_outputs"].discard(frame_idx)\n\n        # Make sure that the frame indices in "consolidated_frame_inds" are exactly those frames\n        # with either points or mask inputs (which should be true under a correct workflow).\n        all_consolidated_frame_inds = (\n            consolidated_frame_inds["cond_frame_outputs"]\n            | consolidated_frame_inds["non_cond_frame_outputs"]\n        )\n        input_frames_inds = set()\n        for point_inputs_per_frame in inference_state["point_inputs_per_obj"].values():\n            input_frames_inds.update(point_inputs_per_frame.keys())\n        for mask_inputs_per_frame in inference_state["mask_inputs_per_obj"].values():\n            input_frames_inds.update(mask_inputs_per_frame.keys())\n        assert all_consolidated_frame_inds == input_frames_inds\n\n    @torch.inference_mode()\n    def propagate_in_video(\n        self,\n        inference_state,\n        start_frame_idx=None,\n        max_frame_num_to_track=None,\n        reverse=False,\n    ):\n        """Propagate the input points across frames to track in the entire video."""\n        self.propagate_in_video_preflight(inference_state)\n\n        output_dict = inference_state["output_dict"]\n        consolidated_frame_inds = inference_state["consolidated_frame_inds"]\n        obj_ids = inference_state["obj_ids"]\n        num_frames = inference_state["num_frames"]\n        batch_size = self._get_obj_num(inference_state)\n        if len(output_dict["cond_frame_outputs"]) == 0:\n            raise RuntimeError("No points are provided; please add points first")\n        clear_non_cond_mem = self.clear_non_cond_mem_around_input and (\n            self.clear_non_cond_mem_for_multi_obj or batch_size <= 1\n        )\n\n        # set start index, end index, and processing order\n        if start_frame_idx is None:\n            # default: start from the earliest frame with input points\n            start_frame_idx = min(output_dict["cond_frame_outputs"])\n        if max_frame_num_to_track is None:\n            # default: track all the frames in the video\n            max_frame_num_to_track = num_frames\n        if reverse:\n            end_frame_idx = max(start_frame_idx - max_frame_num_to_track, 0)\n            if start_frame_idx > 0:\n                processing_order = range(start_frame_idx, end_frame_idx - 1, -1)\n            else:\n                processing_order = []  # skip reverse tracking if starting from frame 0\n        else:\n            end_frame_idx = min(\n                start_frame_idx + max_frame_num_to_track, num_frames - 1\n            )\n            processing_order = range(start_frame_idx, end_frame_idx + 1)\n\n        for frame_idx in tqdm(processing_order, desc="propagate in video"):\n            # We skip those frames already in consolidated outputs (these are frames\n            # that received input clicks or mask). Note that we cannot directly run\n            # batched forward on them via `_run_single_frame_inference` because the\n            # number of clicks on each object might be different.\n            if frame_idx in consolidated_frame_inds["cond_frame_outputs"]:\n                storage_key = "cond_frame_outputs"\n                current_out = output_dict[storage_key][frame_idx]\n                pred_masks = current_out["pred_masks"]\n                if clear_non_cond_mem:\n                    # clear non-conditioning memory of the surrounding frames\n                    self._clear_non_cond_mem_around_input(inference_state, frame_idx)\n            elif frame_idx in consolidated_frame_inds["non_cond_frame_outputs"]:\n                storage_key = "non_cond_frame_outputs"\n                current_out = output_dict[storage_key][frame_idx]\n                pred_masks = current_out["pred_masks"]\n            else:\n                storage_key = "non_cond_frame_outputs"\n                current_out, pred_masks = self._run_single_frame_inference(\n                    inference_state=inference_state,\n                    output_dict=output_dict,\n                    frame_idx=frame_idx,\n                    batch_size=batch_size,\n                    is_init_cond_frame=False,\n                    point_inputs=None,\n                    mask_inputs=None,\n                    reverse=reverse,\n                    run_mem_encoder=True,\n                )\n                output_dict[storage_key][frame_idx] = current_out\n            # Create slices of per-object outputs for subsequent interaction with each\n            # individual object after tracking.\n            self._add_output_per_object(\n                inference_state, frame_idx, current_out, storage_key\n            )\n            inference_state["frames_already_tracked"][frame_idx] = {"reverse": reverse}\n\n            # Resize the output mask to the original video resolution (we directly use\n            # the mask scores on GPU for output to avoid any CPU conversion in between)\n            _, video_res_masks = self._get_orig_video_res_output(\n                inference_state, pred_masks\n            )\n            yield frame_idx, obj_ids, video_res_masks\n\n    def _add_output_per_object(\n        self, inference_state, frame_idx, current_out, storage_key\n    ):\n        """\n        Split a multi-object output into per-object output slices and add them into\n        `output_dict_per_obj`. The resulting slices share the same tensor storage.\n        """\n        maskmem_features = current_out["maskmem_features"]\n        assert maskmem_features is None or isinstance(maskmem_features, torch.Tensor)\n\n        maskmem_pos_enc = current_out["maskmem_pos_enc"]\n        assert maskmem_pos_enc is None or isinstance(maskmem_pos_enc, list)\n\n        output_dict_per_obj = inference_state["output_dict_per_obj"]\n        for obj_idx, obj_output_dict in output_dict_per_obj.items():\n            obj_slice = slice(obj_idx, obj_idx + 1)\n            obj_out = {\n                "maskmem_features": None,\n                "maskmem_pos_enc": None,\n                "pred_masks": current_out["pred_masks"][obj_slice],\n                "obj_ptr": current_out["obj_ptr"][obj_slice],\n                "object_score_logits": current_out["object_score_logits"][obj_slice],\n            }\n            if maskmem_features is not None:\n                obj_out["maskmem_features"] = maskmem_features[obj_slice]\n            if maskmem_pos_enc is not None:\n                obj_out["maskmem_pos_enc"] = [x[obj_slice] for x in maskmem_pos_enc]\n            obj_output_dict[storage_key][frame_idx] = obj_out\n\n    @torch.inference_mode()\n    def clear_all_prompts_in_frame(\n        self, inference_state, frame_idx, obj_id, need_output=True\n    ):\n        """Remove all input points or mask in a specific frame for a given object."""\n        obj_idx = self._obj_id_to_idx(inference_state, obj_id)\n\n        # Clear the conditioning information on the given frame\n        inference_state["point_inputs_per_obj"][obj_idx].pop(frame_idx, None)\n        inference_state["mask_inputs_per_obj"][obj_idx].pop(frame_idx, None)\n\n        temp_output_dict_per_obj = inference_state["temp_output_dict_per_obj"]\n        temp_output_dict_per_obj[obj_idx]["cond_frame_outputs"].pop(frame_idx, None)\n        temp_output_dict_per_obj[obj_idx]["non_cond_frame_outputs"].pop(frame_idx, None)\n\n        # Check and see if there are still any inputs left on this frame\n        batch_size = self._get_obj_num(inference_state)\n        frame_has_input = False\n        for obj_idx2 in range(batch_size):\n            if frame_idx in inference_state["point_inputs_per_obj"][obj_idx2]:\n                frame_has_input = True\n                break\n            if frame_idx in inference_state["mask_inputs_per_obj"][obj_idx2]:\n                frame_has_input = True\n                break\n\n        # If this frame has no remaining inputs for any objects, we further clear its\n        # conditioning frame status\n        if not frame_has_input:\n            output_dict = inference_state["output_dict"]\n            consolidated_frame_inds = inference_state["consolidated_frame_inds"]\n            consolidated_frame_inds["cond_frame_outputs"].discard(frame_idx)\n            consolidated_frame_inds["non_cond_frame_outputs"].discard(frame_idx)\n            # Remove the frame\'s conditioning output (possibly downgrading it to non-conditioning)\n            out = output_dict["cond_frame_outputs"].pop(frame_idx, None)\n            if out is not None:\n                # The frame is not a conditioning frame anymore since it\'s not receiving inputs,\n                # so we "downgrade" its output (if exists) to a non-conditioning frame output.\n                output_dict["non_cond_frame_outputs"][frame_idx] = out\n                inference_state["frames_already_tracked"].pop(frame_idx, None)\n            # Similarly, do it for the sliced output on each object.\n            for obj_idx2 in range(batch_size):\n                obj_output_dict = inference_state["output_dict_per_obj"][obj_idx2]\n                obj_out = obj_output_dict["cond_frame_outputs"].pop(frame_idx, None)\n                if obj_out is not None:\n                    obj_output_dict["non_cond_frame_outputs"][frame_idx] = obj_out\n\n            # If all the conditioning frames have been removed, we also clear the tracking outputs\n            if len(output_dict["cond_frame_outputs"]) == 0:\n                self._reset_tracking_results(inference_state)\n\n        if not need_output:\n            return\n        # Finally, output updated masks per object (after removing the inputs above)\n        obj_ids = inference_state["obj_ids"]\n        is_cond = any(\n            frame_idx in obj_temp_output_dict["cond_frame_outputs"]\n            for obj_temp_output_dict in temp_output_dict_per_obj.values()\n        )\n        consolidated_out = self._consolidate_temp_output_across_obj(\n            inference_state,\n            frame_idx,\n            is_cond=is_cond,\n            run_mem_encoder=False,\n            consolidate_at_video_res=True,\n        )\n        _, video_res_masks = self._get_orig_video_res_output(\n            inference_state, consolidated_out["pred_masks_video_res"]\n        )\n        return frame_idx, obj_ids, video_res_masks\n\n    @torch.inference_mode()\n    def reset_state(self, inference_state):\n        """Remove all input points or mask in all frames throughout the video."""\n        self._reset_tracking_results(inference_state)\n        # Remove all object ids\n        inference_state["obj_id_to_idx"].clear()\n        inference_state["obj_idx_to_id"].clear()\n        inference_state["obj_ids"].clear()\n        inference_state["point_inputs_per_obj"].clear()\n        inference_state["mask_inputs_per_obj"].clear()\n        inference_state["output_dict_per_obj"].clear()\n        inference_state["temp_output_dict_per_obj"].clear()\n\n    def _reset_tracking_results(self, inference_state):\n        """Reset all tracking inputs and results across the videos."""\n        for v in inference_state["point_inputs_per_obj"].values():\n            v.clear()\n        for v in inference_state["mask_inputs_per_obj"].values():\n            v.clear()\n        for v in inference_state["output_dict_per_obj"].values():\n            v["cond_frame_outputs"].clear()\n            v["non_cond_frame_outputs"].clear()\n        for v in inference_state["temp_output_dict_per_obj"].values():\n            v["cond_frame_outputs"].clear()\n            v["non_cond_frame_outputs"].clear()\n        inference_state["output_dict"]["cond_frame_outputs"].clear()\n        inference_state["output_dict"]["non_cond_frame_outputs"].clear()\n        inference_state["consolidated_frame_inds"]["cond_frame_outputs"].clear()\n        inference_state["consolidated_frame_inds"]["non_cond_frame_outputs"].clear()\n        inference_state["tracking_has_started"] = False\n        inference_state["frames_already_tracked"].clear()\n\n    def _get_image_feature(self, inference_state, frame_idx, batch_size):\n        """Compute the image features on a given frame."""\n        # Look up in the cache first\n        image, backbone_out = inference_state["cached_features"].get(\n            frame_idx, (None, None)\n        )\n        if backbone_out is None:\n            # Cache miss -- we will run inference on a single image\n            device = inference_state["device"]\n            image = inference_state["images"][frame_idx].to(device).float().unsqueeze(0)\n            backbone_out = self.forward_image(image)\n            # Cache the most recent frame\'s feature (for repeated interactions with\n            # a frame; we can use an LRU cache for more frames in the future).\n            inference_state["cached_features"] = {frame_idx: (image, backbone_out)}\n\n        # expand the features to have the same dimension as the number of objects\n        expanded_image = image.expand(batch_size, -1, -1, -1)\n        expanded_backbone_out = {\n            "backbone_fpn": backbone_out["backbone_fpn"].copy(),\n            "vision_pos_enc": backbone_out["vision_pos_enc"].copy(),\n        }\n        for i, feat in enumerate(expanded_backbone_out["backbone_fpn"]):\n            expanded_backbone_out["backbone_fpn"][i] = feat.expand(\n                batch_size, -1, -1, -1\n            )\n        for i, pos in enumerate(expanded_backbone_out["vision_pos_enc"]):\n            pos = pos.expand(batch_size, -1, -1, -1)\n            expanded_backbone_out["vision_pos_enc"][i] = pos\n\n        features = self._prepare_backbone_features(expanded_backbone_out)\n        features = (expanded_image,) + features\n        return features\n\n    def _run_single_frame_inference(\n        self,\n        inference_state,\n        output_dict,\n        frame_idx,\n        batch_size,\n        is_init_cond_frame,\n        point_inputs,\n        mask_inputs,\n        reverse,\n        run_mem_encoder,\n        prev_sam_mask_logits=None,\n    ):\n        """Run tracking on a single frame based on current inputs and previous memory."""\n        # Retrieve correct image features\n        (\n            _,\n            _,\n            current_vision_feats,\n            current_vision_pos_embeds,\n            feat_sizes,\n        ) = self._get_image_feature(inference_state, frame_idx, batch_size)\n\n        # point and mask should not appear as input simultaneously on the same frame\n        assert point_inputs is None or mask_inputs is None\n        current_out = self.track_step(\n            frame_idx=frame_idx,\n            is_init_cond_frame=is_init_cond_frame,\n            current_vision_feats=current_vision_feats,\n            current_vision_pos_embeds=current_vision_pos_embeds,\n            feat_sizes=feat_sizes,\n            point_inputs=point_inputs,\n            mask_inputs=mask_inputs,\n            output_dict=output_dict,\n            num_frames=inference_state["num_frames"],\n            track_in_reverse=reverse,\n            run_mem_encoder=run_mem_encoder,\n            prev_sam_mask_logits=prev_sam_mask_logits,\n        )\n\n        # optionally offload the output to CPU memory to save GPU space\n        storage_device = inference_state["storage_device"]\n        maskmem_features = current_out["maskmem_features"]\n        if maskmem_features is not None:\n            maskmem_features = maskmem_features.to(torch.bfloat16)\n            maskmem_features = maskmem_features.to(storage_device, non_blocking=True)\n        pred_masks_gpu = current_out["pred_masks"]\n        # potentially fill holes in the predicted masks\n        if self.fill_hole_area > 0:\n            pred_masks_gpu = fill_holes_in_mask_scores(\n                pred_masks_gpu, self.fill_hole_area\n            )\n        pred_masks = pred_masks_gpu.to(storage_device, non_blocking=True)\n        # "maskmem_pos_enc" is the same across frames, so we only need to store one copy of it\n        maskmem_pos_enc = self._get_maskmem_pos_enc(inference_state, current_out)\n        # object pointer is a small tensor, so we always keep it on GPU memory for fast access\n        obj_ptr = current_out["obj_ptr"]\n        object_score_logits = current_out["object_score_logits"]\n        # make a compact version of this frame\'s output to reduce the state size\n        compact_current_out = {\n            "maskmem_features": maskmem_features,\n            "maskmem_pos_enc": maskmem_pos_enc,\n            "pred_masks": pred_masks,\n            "obj_ptr": obj_ptr,\n            "object_score_logits": object_score_logits,\n        }\n        return compact_current_out, pred_masks_gpu\n\n    def _run_memory_encoder(\n        self,\n        inference_state,\n        frame_idx,\n        batch_size,\n        high_res_masks,\n        object_score_logits,\n        is_mask_from_pts,\n    ):\n        """\n        Run the memory encoder on `high_res_masks`. This is usually after applying\n        non-overlapping constraints to object scores. Since their scores changed, their\n        memory also need to be computed again with the memory encoder.\n        """\n        # Retrieve correct image features\n        _, _, current_vision_feats, _, feat_sizes = self._get_image_feature(\n            inference_state, frame_idx, batch_size\n        )\n        maskmem_features, maskmem_pos_enc = self._encode_new_memory(\n            current_vision_feats=current_vision_feats,\n            feat_sizes=feat_sizes,\n            pred_masks_high_res=high_res_masks,\n            object_score_logits=object_score_logits,\n            is_mask_from_pts=is_mask_from_pts,\n        )\n\n        # optionally offload the output to CPU memory to save GPU space\n        storage_device = inference_state["storage_device"]\n        maskmem_features = maskmem_features.to(torch.bfloat16)\n        maskmem_features = maskmem_features.to(storage_device, non_blocking=True)\n        # "maskmem_pos_enc" is the same across frames, so we only need to store one copy of it\n        maskmem_pos_enc = self._get_maskmem_pos_enc(\n            inference_state, {"maskmem_pos_enc": maskmem_pos_enc}\n        )\n        return maskmem_features, maskmem_pos_enc\n\n    def _get_maskmem_pos_enc(self, inference_state, current_out):\n        """\n        `maskmem_pos_enc` is the same across frames and objects, so we cache it as\n        a constant in the inference session to reduce session storage size.\n        """\n        model_constants = inference_state["constants"]\n        # "out_maskmem_pos_enc" should be either a list of tensors or None\n        out_maskmem_pos_enc = current_out["maskmem_pos_enc"]\n        if out_maskmem_pos_enc is not None:\n            if "maskmem_pos_enc" not in model_constants:\n                assert isinstance(out_maskmem_pos_enc, list)\n                # only take the slice for one object, since it\'s same across objects\n                maskmem_pos_enc = [x[0:1].clone() for x in out_maskmem_pos_enc]\n                model_constants["maskmem_pos_enc"] = maskmem_pos_enc\n            else:\n                maskmem_pos_enc = model_constants["maskmem_pos_enc"]\n            # expand the cached maskmem_pos_enc to the actual batch size\n            batch_size = out_maskmem_pos_enc[0].size(0)\n            expanded_maskmem_pos_enc = [\n                x.expand(batch_size, -1, -1, -1) for x in maskmem_pos_enc\n            ]\n        else:\n            expanded_maskmem_pos_enc = None\n        return expanded_maskmem_pos_enc\n\n    @torch.inference_mode()\n    def remove_object(self, inference_state, obj_id, strict=False, need_output=True):\n        """\n        Remove an object id from the tracking state. If strict is True, we check whether\n        the object id actually exists and raise an error if it doesn\'t exist.\n        """\n        old_obj_idx_to_rm = inference_state["obj_id_to_idx"].get(obj_id, None)\n        updated_frames = []\n        # Check whether this object_id to remove actually exists and possibly raise an error.\n        if old_obj_idx_to_rm is None:\n            if not strict:\n                return inference_state["obj_ids"], updated_frames\n            raise RuntimeError(\n                f"Cannot remove object id {obj_id} as it doesn\'t exist. "\n                f"All existing object ids: {inference_state[\'obj_ids\']}."\n            )\n\n        # If this is the only remaining object id, we simply reset the state.\n        if len(inference_state["obj_id_to_idx"]) == 1:\n            self.reset_state(inference_state)\n            return inference_state["obj_ids"], updated_frames\n\n        # There are still remaining objects after removing this object id. In this case,\n        # we need to delete the object storage from inference state tensors.\n        # Step 0: clear the input on those frames where this object id has point or mask input\n        # (note that this step is required as it might downgrade conditioning frames to\n        # non-conditioning ones)\n        obj_input_frames_inds = set()\n        obj_input_frames_inds.update(\n            inference_state["point_inputs_per_obj"][old_obj_idx_to_rm]\n        )\n        obj_input_frames_inds.update(\n            inference_state["mask_inputs_per_obj"][old_obj_idx_to_rm]\n        )\n        for frame_idx in obj_input_frames_inds:\n            self.clear_all_prompts_in_frame(\n                inference_state, frame_idx, obj_id, need_output=False\n            )\n\n        # Step 1: Update the object id mapping (note that it must be done after Step 0,\n        # since Step 0 still requires the old object id mappings in inference_state)\n        old_obj_ids = inference_state["obj_ids"]\n        old_obj_inds = list(range(len(old_obj_ids)))\n        remain_old_obj_inds = old_obj_inds.copy()\n        remain_old_obj_inds.remove(old_obj_idx_to_rm)\n        new_obj_ids = [old_obj_ids[old_idx] for old_idx in remain_old_obj_inds]\n        new_obj_inds = list(range(len(new_obj_ids)))\n        # build new mappings\n        old_idx_to_new_idx = dict(zip(remain_old_obj_inds, new_obj_inds))\n        inference_state["obj_id_to_idx"] = dict(zip(new_obj_ids, new_obj_inds))\n        inference_state["obj_idx_to_id"] = dict(zip(new_obj_inds, new_obj_ids))\n        inference_state["obj_ids"] = new_obj_ids\n\n        # Step 2: For per-object tensor storage, we shift their obj_idx in the dict keys.\n        # (note that "consolidated_frame_inds" doesn\'t need to be updated in this step as\n        # it\'s already handled in Step 0)\n        def _map_keys(container):\n            new_kvs = []\n            for k in old_obj_inds:\n                v = container.pop(k)\n                if k in old_idx_to_new_idx:\n                    new_kvs.append((old_idx_to_new_idx[k], v))\n            container.update(new_kvs)\n\n        _map_keys(inference_state["point_inputs_per_obj"])\n        _map_keys(inference_state["mask_inputs_per_obj"])\n        _map_keys(inference_state["output_dict_per_obj"])\n        _map_keys(inference_state["temp_output_dict_per_obj"])\n\n        # Step 3: For packed tensor storage, we index the remaining ids and rebuild the per-object slices.\n        def _slice_state(output_dict, storage_key):\n            for frame_idx, out in output_dict[storage_key].items():\n                out["maskmem_features"] = out["maskmem_features"][remain_old_obj_inds]\n                out["maskmem_pos_enc"] = [\n                    x[remain_old_obj_inds] for x in out["maskmem_pos_enc"]\n                ]\n                # "maskmem_pos_enc" is the same across frames, so we only need to store one copy of it\n                out["maskmem_pos_enc"] = self._get_maskmem_pos_enc(inference_state, out)\n                out["pred_masks"] = out["pred_masks"][remain_old_obj_inds]\n                out["obj_ptr"] = out["obj_ptr"][remain_old_obj_inds]\n                out["object_score_logits"] = out["object_score_logits"][\n                    remain_old_obj_inds\n                ]\n                # also update the per-object slices\n                self._add_output_per_object(\n                    inference_state, frame_idx, out, storage_key\n                )\n\n        _slice_state(inference_state["output_dict"], "cond_frame_outputs")\n        _slice_state(inference_state["output_dict"], "non_cond_frame_outputs")\n\n        # Step 4: Further collect the outputs on those frames in `obj_input_frames_inds`, which\n        # could show an updated mask for objects previously occluded by the object being removed\n        if need_output:\n            temp_output_dict_per_obj = inference_state["temp_output_dict_per_obj"]\n            for frame_idx in obj_input_frames_inds:\n                is_cond = any(\n                    frame_idx in obj_temp_output_dict["cond_frame_outputs"]\n                    for obj_temp_output_dict in temp_output_dict_per_obj.values()\n                )\n                consolidated_out = self._consolidate_temp_output_across_obj(\n                    inference_state,\n                    frame_idx,\n                    is_cond=is_cond,\n                    run_mem_encoder=False,\n                    consolidate_at_video_res=True,\n                )\n                _, video_res_masks = self._get_orig_video_res_output(\n                    inference_state, consolidated_out["pred_masks_video_res"]\n                )\n                updated_frames.append((frame_idx, video_res_masks))\n\n        return inference_state["obj_ids"], updated_frames\n\n    def _clear_non_cond_mem_around_input(self, inference_state, frame_idx):\n        """\n        Remove the non-conditioning memory around the input frame. When users provide\n        correction clicks, the surrounding frames\' non-conditioning memories can still\n        contain outdated object appearance information and could confuse the model.\n\n        This method clears those non-conditioning memories surrounding the interacted\n        frame to avoid giving the model both old and new information about the object.\n        """\n        r = self.memory_temporal_stride_for_eval\n        frame_idx_begin = frame_idx - r * self.num_maskmem\n        frame_idx_end = frame_idx + r * self.num_maskmem\n        output_dict = inference_state["output_dict"]\n        non_cond_frame_outputs = output_dict["non_cond_frame_outputs"]\n        for t in range(frame_idx_begin, frame_idx_end + 1):\n            non_cond_frame_outputs.pop(t, None)\n            for obj_output_dict in inference_state["output_dict_per_obj"].values():\n                obj_output_dict["non_cond_frame_outputs"].pop(t, None)\n\n',
    'sam2.utils': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n',
    'sam2.utils.amg': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom copy import deepcopy\nfrom itertools import product\nfrom typing import Any, Dict, Generator, ItemsView, List, Tuple\n\nimport numpy as np\nimport torch\n\n# Very lightly adapted from https://github.com/facebookresearch/segment-anything/blob/main/segment_anything/utils/amg.py\n\n\nclass MaskData:\n    """\n    A structure for storing masks and their related data in batched format.\n    Implements basic filtering and concatenation.\n    """\n\n    def __init__(self, **kwargs) -> None:\n        for v in kwargs.values():\n            assert isinstance(\n                v, (list, np.ndarray, torch.Tensor)\n            ), "MaskData only supports list, numpy arrays, and torch tensors."\n        self._stats = dict(**kwargs)\n\n    def __setitem__(self, key: str, item: Any) -> None:\n        assert isinstance(\n            item, (list, np.ndarray, torch.Tensor)\n        ), "MaskData only supports list, numpy arrays, and torch tensors."\n        self._stats[key] = item\n\n    def __delitem__(self, key: str) -> None:\n        del self._stats[key]\n\n    def __getitem__(self, key: str) -> Any:\n        return self._stats[key]\n\n    def items(self) -> ItemsView[str, Any]:\n        return self._stats.items()\n\n    def filter(self, keep: torch.Tensor) -> None:\n        for k, v in self._stats.items():\n            if v is None:\n                self._stats[k] = None\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = v[torch.as_tensor(keep, device=v.device)]\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = v[keep.detach().cpu().numpy()]\n            elif isinstance(v, list) and keep.dtype == torch.bool:\n                self._stats[k] = [a for i, a in enumerate(v) if keep[i]]\n            elif isinstance(v, list):\n                self._stats[k] = [v[i] for i in keep]\n            else:\n                raise TypeError(f"MaskData key {k} has an unsupported type {type(v)}.")\n\n    def cat(self, new_stats: "MaskData") -> None:\n        for k, v in new_stats.items():\n            if k not in self._stats or self._stats[k] is None:\n                self._stats[k] = deepcopy(v)\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = torch.cat([self._stats[k], v], dim=0)\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = np.concatenate([self._stats[k], v], axis=0)\n            elif isinstance(v, list):\n                self._stats[k] = self._stats[k] + deepcopy(v)\n            else:\n                raise TypeError(f"MaskData key {k} has an unsupported type {type(v)}.")\n\n    def to_numpy(self) -> None:\n        for k, v in self._stats.items():\n            if isinstance(v, torch.Tensor):\n                self._stats[k] = v.float().detach().cpu().numpy()\n\n\ndef is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -> torch.Tensor:\n    """Filter masks at the edge of a crop, but not at the edge of the original image."""\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)\n    return torch.any(near_crop_edge, dim=1)\n\n\ndef box_xyxy_to_xywh(box_xyxy: torch.Tensor) -> torch.Tensor:\n    box_xywh = deepcopy(box_xyxy)\n    box_xywh[2] = box_xywh[2] - box_xywh[0]\n    box_xywh[3] = box_xywh[3] - box_xywh[1]\n    return box_xywh\n\n\ndef batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    assert len(args) > 0 and all(\n        len(a) == len(args[0]) for a in args\n    ), "Batched iteration must have inputs of all the same size."\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\n\n\ndef mask_to_rle_pytorch(tensor: torch.Tensor) -> List[Dict[str, Any]]:\n    """\n    Encodes masks to an uncompressed RLE, in the format expected by\n    pycoco tools.\n    """\n    # Put in fortran order and flatten h,w\n    b, h, w = tensor.shape\n    tensor = tensor.permute(0, 2, 1).flatten(1)\n\n    # Compute change indices\n    diff = tensor[:, 1:] ^ tensor[:, :-1]\n    change_indices = diff.nonzero()\n\n    # Encode run length\n    out = []\n    for i in range(b):\n        cur_idxs = change_indices[change_indices[:, 0] == i, 1]\n        cur_idxs = torch.cat(\n            [\n                torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),\n                cur_idxs + 1,\n                torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),\n            ]\n        )\n        btw_idxs = cur_idxs[1:] - cur_idxs[:-1]\n        counts = [] if tensor[i, 0] == 0 else [0]\n        counts.extend(btw_idxs.detach().cpu().tolist())\n        out.append({"size": [h, w], "counts": counts})\n    return out\n\n\ndef rle_to_mask(rle: Dict[str, Any]) -> np.ndarray:\n    """Compute a binary mask from an uncompressed RLE."""\n    h, w = rle["size"]\n    mask = np.empty(h * w, dtype=bool)\n    idx = 0\n    parity = False\n    for count in rle["counts"]:\n        mask[idx : idx + count] = parity\n        idx += count\n        parity ^= True\n    mask = mask.reshape(w, h)\n    return mask.transpose()  # Put in C order\n\n\ndef area_from_rle(rle: Dict[str, Any]) -> int:\n    return sum(rle["counts"][1::2])\n\n\ndef calculate_stability_score(\n    masks: torch.Tensor, mask_threshold: float, threshold_offset: float\n) -> torch.Tensor:\n    """\n    Computes the stability score for a batch of masks. The stability\n    score is the IoU between the binary masks obtained by thresholding\n    the predicted mask logits at high and low values.\n    """\n    # One mask is always contained inside the other.\n    # Save memory by preventing unnecessary cast to torch.int64\n    intersections = (\n        (masks > (mask_threshold + threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    unions = (\n        (masks > (mask_threshold - threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    return intersections / unions\n\n\ndef build_point_grid(n_per_side: int) -> np.ndarray:\n    """Generates a 2D grid of points evenly spaced in [0,1]x[0,1]."""\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    points = np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\n    return points\n\n\ndef build_all_layer_point_grids(\n    n_per_side: int, n_layers: int, scale_per_layer: int\n) -> List[np.ndarray]:\n    """Generates point grids for all crop layers."""\n    points_by_layer = []\n    for i in range(n_layers + 1):\n        n_points = int(n_per_side / (scale_per_layer**i))\n        points_by_layer.append(build_point_grid(n_points))\n    return points_by_layer\n\n\ndef generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    """\n    Generates a list of crop boxes of different sizes. Each layer\n    has (2**i)**2 boxes for the ith layer.\n    """\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)\n\n    # Original image\n    crop_boxes.append([0, 0, im_w, im_h])\n    layer_idxs.append(0)\n\n    def crop_len(orig_len, n_crops, overlap):\n        return int(math.ceil((overlap * (n_crops - 1) + orig_len) / n_crops))\n\n    for i_layer in range(n_layers):\n        n_crops_per_side = 2 ** (i_layer + 1)\n        overlap = int(overlap_ratio * short_side * (2 / n_crops_per_side))\n\n        crop_w = crop_len(im_w, n_crops_per_side, overlap)\n        crop_h = crop_len(im_h, n_crops_per_side, overlap)\n\n        crop_box_x0 = [int((crop_w - overlap) * i) for i in range(n_crops_per_side)]\n        crop_box_y0 = [int((crop_h - overlap) * i) for i in range(n_crops_per_side)]\n\n        # Crops in XYWH format\n        for x0, y0 in product(crop_box_x0, crop_box_y0):\n            box = [x0, y0, min(x0 + crop_w, im_w), min(y0 + crop_h, im_h)]\n            crop_boxes.append(box)\n            layer_idxs.append(i_layer + 1)\n\n    return crop_boxes, layer_idxs\n\n\ndef uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\n\n\ndef uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\n\n\ndef uncrop_masks(\n    masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int\n) -> torch.Tensor:\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)\n\n\ndef remove_small_regions(\n    mask: np.ndarray, area_thresh: float, mode: str\n) -> Tuple[np.ndarray, bool]:\n    """\n    Removes small disconnected regions and holes in a mask. Returns the\n    mask and an indicator of if the mask has been modified.\n    """\n    import cv2  # type: ignore\n\n    assert mode in ["holes", "islands"]\n    correct_holes = mode == "holes"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]\n    if len(small_regions) == 0:\n        return mask, False\n    fill_labels = [0] + small_regions\n    if not correct_holes:\n        fill_labels = [i for i in range(n_labels) if i not in fill_labels]\n        # If every region is below threshold, keep largest\n        if len(fill_labels) == 0:\n            fill_labels = [int(np.argmax(sizes)) + 1]\n    mask = np.isin(regions, fill_labels)\n    return mask, True\n\n\ndef coco_encode_rle(uncompressed_rle: Dict[str, Any]) -> Dict[str, Any]:\n    from pycocotools import mask as mask_utils  # type: ignore\n\n    h, w = uncompressed_rle["size"]\n    rle = mask_utils.frPyObjects(uncompressed_rle, h, w)\n    rle["counts"] = rle["counts"].decode("utf-8")  # Necessary to serialize with json\n    return rle\n\n\ndef batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    """\n    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for\n    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    """\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n\n    # Normalize shape to CxHxW\n    shape = masks.shape\n    h, w = shape[-2:]\n    if len(shape) > 2:\n        masks = masks.flatten(0, -3)\n    else:\n        masks = masks.unsqueeze(0)\n\n    # Get top and bottom edges\n    in_height, _ = torch.max(masks, dim=-1)\n    in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]\n    bottom_edges, _ = torch.max(in_height_coords, dim=-1)\n    in_height_coords = in_height_coords + h * (~in_height)\n    top_edges, _ = torch.min(in_height_coords, dim=-1)\n\n    # Get left and right edges\n    in_width, _ = torch.max(masks, dim=-2)\n    in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]\n    right_edges, _ = torch.max(in_width_coords, dim=-1)\n    in_width_coords = in_width_coords + w * (~in_width)\n    left_edges, _ = torch.min(in_width_coords, dim=-1)\n\n    # If the mask is empty the right edge will be to the left of the left edge.\n    # Replace these boxes with [0, 0, 0, 0]\n    empty_filter = (right_edges < left_edges) | (bottom_edges < top_edges)\n    out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)\n    out = out * (~empty_filter).unsqueeze(-1)\n\n    # Return to original shape\n    if len(shape) > 2:\n        out = out.reshape(*shape[:-2], 4)\n    else:\n        out = out[0]\n\n    return out\n',
    'sam2.utils.misc': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport os\nimport warnings\nfrom threading import Thread\n\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom tqdm import tqdm\n\n\ndef get_sdpa_settings():\n    if torch.cuda.is_available():\n        old_gpu = torch.cuda.get_device_properties(0).major < 7\n        # only use Flash Attention on Ampere (8.0) or newer GPUs\n        use_flash_attn = torch.cuda.get_device_properties(0).major >= 8\n        if not use_flash_attn:\n            warnings.warn(\n                "Flash Attention is disabled as it requires a GPU with Ampere (8.0) CUDA capability.",\n                category=UserWarning,\n                stacklevel=2,\n            )\n        # keep math kernel for PyTorch versions before 2.2 (Flash Attention v2 is only\n        # available on PyTorch 2.2+, while Flash Attention v1 cannot handle all cases)\n        pytorch_version = tuple(int(v) for v in torch.__version__.split(".")[:2])\n        if pytorch_version < (2, 2):\n            warnings.warn(\n                f"You are using PyTorch {torch.__version__} without Flash Attention v2 support. "\n                "Consider upgrading to PyTorch 2.2+ for Flash Attention v2 (which could be faster).",\n                category=UserWarning,\n                stacklevel=2,\n            )\n        math_kernel_on = pytorch_version < (2, 2) or not use_flash_attn\n    else:\n        old_gpu = True\n        use_flash_attn = False\n        math_kernel_on = True\n\n    return old_gpu, use_flash_attn, math_kernel_on\n\n\ndef get_connected_components(mask):\n    """\n    Get the connected components (8-connectivity) of binary masks of shape (N, 1, H, W).\n\n    Inputs:\n    - mask: A binary mask tensor of shape (N, 1, H, W), where 1 is foreground and 0 is\n            background.\n\n    Outputs:\n    - labels: A tensor of shape (N, 1, H, W) containing the connected component labels\n              for foreground pixels and 0 for background pixels.\n    - counts: A tensor of shape (N, 1, H, W) containing the area of the connected\n              components for foreground pixels and 0 for background pixels.\n    """\n    from sam2 import _C\n\n    return _C.get_connected_componnets(mask.to(torch.uint8).contiguous())\n\n\ndef mask_to_box(masks: torch.Tensor):\n    """\n    compute bounding box given an input mask\n\n    Inputs:\n    - masks: [B, 1, H, W] masks, dtype=torch.Tensor\n\n    Returns:\n    - box_coords: [B, 1, 4], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.Tensor\n    """\n    B, _, h, w = masks.shape\n    device = masks.device\n    xs = torch.arange(w, device=device, dtype=torch.int32)\n    ys = torch.arange(h, device=device, dtype=torch.int32)\n    grid_xs, grid_ys = torch.meshgrid(xs, ys, indexing="xy")\n    grid_xs = grid_xs[None, None, ...].expand(B, 1, h, w)\n    grid_ys = grid_ys[None, None, ...].expand(B, 1, h, w)\n    min_xs, _ = torch.min(torch.where(masks, grid_xs, w).flatten(-2), dim=-1)\n    max_xs, _ = torch.max(torch.where(masks, grid_xs, -1).flatten(-2), dim=-1)\n    min_ys, _ = torch.min(torch.where(masks, grid_ys, h).flatten(-2), dim=-1)\n    max_ys, _ = torch.max(torch.where(masks, grid_ys, -1).flatten(-2), dim=-1)\n    bbox_coords = torch.stack((min_xs, min_ys, max_xs, max_ys), dim=-1)\n\n    return bbox_coords\n\n\ndef _load_img_as_tensor(img_path, image_size):\n    img_pil = Image.open(img_path)\n    img_np = np.array(img_pil.convert("RGB").resize((image_size, image_size)))\n    if img_np.dtype == np.uint8:  # np.uint8 is expected for JPEG images\n        img_np = img_np / 255.0\n    else:\n        raise RuntimeError(f"Unknown image dtype: {img_np.dtype} on {img_path}")\n    img = torch.from_numpy(img_np).permute(2, 0, 1)\n    video_width, video_height = img_pil.size  # the original video size\n    return img, video_height, video_width\n\n\nclass AsyncVideoFrameLoader:\n    """\n    A list of video frames to be load asynchronously without blocking session start.\n    """\n\n    def __init__(\n        self,\n        img_paths,\n        image_size,\n        offload_video_to_cpu,\n        img_mean,\n        img_std,\n        compute_device,\n    ):\n        self.img_paths = img_paths\n        self.image_size = image_size\n        self.offload_video_to_cpu = offload_video_to_cpu\n        self.img_mean = img_mean\n        self.img_std = img_std\n        # items in `self.images` will be loaded asynchronously\n        self.images = [None] * len(img_paths)\n        # catch and raise any exceptions in the async loading thread\n        self.exception = None\n        # video_height and video_width be filled when loading the first image\n        self.video_height = None\n        self.video_width = None\n        self.compute_device = compute_device\n\n        # load the first frame to fill video_height and video_width and also\n        # to cache it (since it\'s most likely where the user will click)\n        self.__getitem__(0)\n\n        # load the rest of frames asynchronously without blocking the session start\n        def _load_frames():\n            try:\n                for n in tqdm(range(len(self.images)), desc="frame loading (JPEG)"):\n                    self.__getitem__(n)\n            except Exception as e:\n                self.exception = e\n\n        self.thread = Thread(target=_load_frames, daemon=True)\n        self.thread.start()\n\n    def __getitem__(self, index):\n        if self.exception is not None:\n            raise RuntimeError("Failure in frame loading thread") from self.exception\n\n        img = self.images[index]\n        if img is not None:\n            return img\n\n        img, video_height, video_width = _load_img_as_tensor(\n            self.img_paths[index], self.image_size\n        )\n        self.video_height = video_height\n        self.video_width = video_width\n        # normalize by mean and std\n        img -= self.img_mean\n        img /= self.img_std\n        if not self.offload_video_to_cpu:\n            img = img.to(self.compute_device, non_blocking=True)\n        self.images[index] = img\n        return img\n\n    def __len__(self):\n        return len(self.images)\n\n\ndef load_video_frames(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    async_loading_frames=False,\n    compute_device=torch.device("cuda"),\n):\n    """\n    Load the video frames from video_path. The frames are resized to image_size as in\n    the model and are loaded to GPU if offload_video_to_cpu=False. This is used by the demo.\n    """\n    is_bytes = isinstance(video_path, bytes)\n    is_str = isinstance(video_path, str)\n    is_mp4_path = is_str and os.path.splitext(video_path)[-1] in [".mp4", ".MP4"]\n    if is_bytes or is_mp4_path:\n        return load_video_frames_from_video_file(\n            video_path=video_path,\n            image_size=image_size,\n            offload_video_to_cpu=offload_video_to_cpu,\n            img_mean=img_mean,\n            img_std=img_std,\n            compute_device=compute_device,\n        )\n    elif is_str and os.path.isdir(video_path):\n        return load_video_frames_from_jpg_images(\n            video_path=video_path,\n            image_size=image_size,\n            offload_video_to_cpu=offload_video_to_cpu,\n            img_mean=img_mean,\n            img_std=img_std,\n            async_loading_frames=async_loading_frames,\n            compute_device=compute_device,\n        )\n    else:\n        raise NotImplementedError(\n            "Only MP4 video and JPEG folder are supported at this moment"\n        )\n\n\ndef load_video_frames_from_jpg_images(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    async_loading_frames=False,\n    compute_device=torch.device("cuda"),\n):\n    """\n    Load the video frames from a directory of JPEG files ("<frame_index>.jpg" format).\n\n    The frames are resized to image_size x image_size and are loaded to GPU if\n    `offload_video_to_cpu` is `False` and to CPU if `offload_video_to_cpu` is `True`.\n\n    You can load a frame asynchronously by setting `async_loading_frames` to `True`.\n    """\n    if isinstance(video_path, str) and os.path.isdir(video_path):\n        jpg_folder = video_path\n    else:\n        raise NotImplementedError(\n            "Only JPEG frames are supported at this moment. For video files, you may use "\n            "ffmpeg (https://ffmpeg.org/) to extract frames into a folder of JPEG files, such as \\n"\n            "```\\n"\n            "ffmpeg -i <your_video>.mp4 -q:v 2 -start_number 0 <output_dir>/\'%05d.jpg\'\\n"\n            "```\\n"\n            "where `-q:v` generates high-quality JPEG frames and `-start_number 0` asks "\n            "ffmpeg to start the JPEG file from 00000.jpg."\n        )\n\n    frame_names = [\n        p\n        for p in os.listdir(jpg_folder)\n        if os.path.splitext(p)[-1] in [".jpg", ".jpeg", ".JPG", ".JPEG"]\n    ]\n    frame_names.sort()\n    num_frames = len(frame_names)\n    if num_frames == 0:\n        raise RuntimeError(f"no images found in {jpg_folder}")\n    img_paths = [os.path.join(jpg_folder, frame_name) for frame_name in frame_names]\n    img_mean = torch.tensor(img_mean, dtype=torch.float32)[:, None, None]\n    img_std = torch.tensor(img_std, dtype=torch.float32)[:, None, None]\n\n    if async_loading_frames:\n        lazy_images = AsyncVideoFrameLoader(\n            img_paths,\n            image_size,\n            offload_video_to_cpu,\n            img_mean,\n            img_std,\n            compute_device,\n        )\n        return lazy_images, lazy_images.video_height, lazy_images.video_width\n\n    images = torch.zeros(num_frames, 3, image_size, image_size, dtype=torch.float32)\n    for n, img_path in enumerate(tqdm(img_paths, desc="frame loading (JPEG)")):\n        images[n], video_height, video_width = _load_img_as_tensor(img_path, image_size)\n    if not offload_video_to_cpu:\n        images = images.to(compute_device)\n        img_mean = img_mean.to(compute_device)\n        img_std = img_std.to(compute_device)\n    # normalize by mean and std\n    images -= img_mean\n    images /= img_std\n    return images, video_height, video_width\n\n\ndef load_video_frames_from_video_file(\n    video_path,\n    image_size,\n    offload_video_to_cpu,\n    img_mean=(0.485, 0.456, 0.406),\n    img_std=(0.229, 0.224, 0.225),\n    compute_device=torch.device("cuda"),\n):\n    """Load the video frames from a video file."""\n    import decord\n\n    img_mean = torch.tensor(img_mean, dtype=torch.float32)[:, None, None]\n    img_std = torch.tensor(img_std, dtype=torch.float32)[:, None, None]\n    # Get the original video height and width\n    decord.bridge.set_bridge("torch")\n    video_height, video_width, _ = decord.VideoReader(video_path).next().shape\n    # Iterate over all frames in the video\n    images = []\n    for frame in decord.VideoReader(video_path, width=image_size, height=image_size):\n        images.append(frame.permute(2, 0, 1))\n\n    images = torch.stack(images, dim=0).float() / 255.0\n    if not offload_video_to_cpu:\n        images = images.to(compute_device)\n        img_mean = img_mean.to(compute_device)\n        img_std = img_std.to(compute_device)\n    # normalize by mean and std\n    images -= img_mean\n    images /= img_std\n    return images, video_height, video_width\n\n\ndef fill_holes_in_mask_scores(mask, max_area):\n    """\n    A post processor to fill small holes in mask scores with area under `max_area`.\n    """\n    # Holes are those connected components in background with area <= self.max_area\n    # (background regions are those with mask scores <= 0)\n    assert max_area > 0, "max_area must be positive"\n\n    input_mask = mask\n    try:\n        labels, areas = get_connected_components(mask <= 0)\n        is_hole = (labels > 0) & (areas <= max_area)\n        # We fill holes with a small positive mask score (0.1) to change them to foreground.\n        mask = torch.where(is_hole, 0.1, mask)\n    except Exception as e:\n        # Skip the post-processing step on removing small holes if the CUDA kernel fails\n        warnings.warn(\n            f"{e}\\n\\nSkipping the post-processing step due to the error above. You can "\n            "still use SAM 2 and it\'s OK to ignore the error above, although some post-processing "\n            "functionality may be limited (which doesn\'t affect the results in most cases; see "\n            "https://github.com/facebookresearch/sam2/blob/main/INSTALL.md).",\n            category=UserWarning,\n            stacklevel=2,\n        )\n        mask = input_mask\n\n    return mask\n\n\ndef concat_points(old_point_inputs, new_points, new_labels):\n    """Add new points and labels to previous point inputs (add at the end)."""\n    if old_point_inputs is None:\n        points, labels = new_points, new_labels\n    else:\n        points = torch.cat([old_point_inputs["point_coords"], new_points], dim=1)\n        labels = torch.cat([old_point_inputs["point_labels"], new_labels], dim=1)\n\n    return {"point_coords": points, "point_labels": labels}\n',
    'sam2.utils.transforms': '# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport warnings\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision.transforms import Normalize, Resize, ToTensor\n\n\nclass SAM2Transforms(nn.Module):\n    def __init__(\n        self, resolution, mask_threshold, max_hole_area=0.0, max_sprinkle_area=0.0\n    ):\n        """\n        Transforms for SAM2.\n        """\n        super().__init__()\n        self.resolution = resolution\n        self.mask_threshold = mask_threshold\n        self.max_hole_area = max_hole_area\n        self.max_sprinkle_area = max_sprinkle_area\n        self.mean = [0.485, 0.456, 0.406]\n        self.std = [0.229, 0.224, 0.225]\n        self.to_tensor = ToTensor()\n        self.transforms = torch.jit.script(\n            nn.Sequential(\n                Resize((self.resolution, self.resolution)),\n                Normalize(self.mean, self.std),\n            )\n        )\n\n    def __call__(self, x):\n        x = self.to_tensor(x)\n        return self.transforms(x)\n\n    def forward_batch(self, img_list):\n        img_batch = [self.transforms(self.to_tensor(img)) for img in img_list]\n        img_batch = torch.stack(img_batch, dim=0)\n        return img_batch\n\n    def transform_coords(\n        self, coords: torch.Tensor, normalize=False, orig_hw=None\n    ) -> torch.Tensor:\n        """\n        Expects a torch tensor with length 2 in the last dimension. The coordinates can be in absolute image or normalized coordinates,\n        If the coords are in absolute image coordinates, normalize should be set to True and original image size is required.\n\n        Returns\n            Un-normalized coordinates in the range of [0, 1] which is expected by the SAM2 model.\n        """\n        if normalize:\n            assert orig_hw is not None\n            h, w = orig_hw\n            coords = coords.clone()\n            coords[..., 0] = coords[..., 0] / w\n            coords[..., 1] = coords[..., 1] / h\n\n        coords = coords * self.resolution  # unnormalize coords\n        return coords\n\n    def transform_boxes(\n        self, boxes: torch.Tensor, normalize=False, orig_hw=None\n    ) -> torch.Tensor:\n        """\n        Expects a tensor of shape Bx4. The coordinates can be in absolute image or normalized coordinates,\n        if the coords are in absolute image coordinates, normalize should be set to True and original image size is required.\n        """\n        boxes = self.transform_coords(boxes.reshape(-1, 2, 2), normalize, orig_hw)\n        return boxes\n\n    def postprocess_masks(self, masks: torch.Tensor, orig_hw) -> torch.Tensor:\n        """\n        Perform PostProcessing on output masks.\n        """\n        from sam2.utils.misc import get_connected_components\n\n        masks = masks.float()\n        input_masks = masks\n        mask_flat = masks.flatten(0, 1).unsqueeze(1)  # flatten as 1-channel image\n        try:\n            if self.max_hole_area > 0:\n                # Holes are those connected components in background with area <= self.fill_hole_area\n                # (background regions are those with mask scores <= self.mask_threshold)\n                labels, areas = get_connected_components(\n                    mask_flat <= self.mask_threshold\n                )\n                is_hole = (labels > 0) & (areas <= self.max_hole_area)\n                is_hole = is_hole.reshape_as(masks)\n                # We fill holes with a small positive mask score (10.0) to change them to foreground.\n                masks = torch.where(is_hole, self.mask_threshold + 10.0, masks)\n\n            if self.max_sprinkle_area > 0:\n                labels, areas = get_connected_components(\n                    mask_flat > self.mask_threshold\n                )\n                is_hole = (labels > 0) & (areas <= self.max_sprinkle_area)\n                is_hole = is_hole.reshape_as(masks)\n                # We fill holes with negative mask score (-10.0) to change them to background.\n                masks = torch.where(is_hole, self.mask_threshold - 10.0, masks)\n        except Exception as e:\n            # Skip the post-processing step if the CUDA kernel fails\n            warnings.warn(\n                f"{e}\\n\\nSkipping the post-processing step due to the error above. You can "\n                "still use SAM 2 and it\'s OK to ignore the error above, although some post-processing "\n                "functionality may be limited (which doesn\'t affect the results in most cases; see "\n                "https://github.com/facebookresearch/sam2/blob/main/INSTALL.md).",\n                category=UserWarning,\n                stacklevel=2,\n            )\n            masks = input_masks\n\n        masks = F.interpolate(masks, orig_hw, mode="bilinear", align_corners=False)\n        return masks\n',
}

_EMBEDDED_PACKAGES = {
    name for name in EMBEDDED_SOURCES if any(other.startswith(f"{name}.") for other in EMBEDDED_SOURCES)
}


class _EmbeddedLoader(importlib.abc.Loader):
    def create_module(self, spec):
        return None

    def exec_module(self, module):
        source = EMBEDDED_SOURCES[module.__name__]
        module.__file__ = f"<embedded {module.__name__}>"
        exec(compile(source, module.__file__, "exec"), module.__dict__)


class _EmbeddedFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        if fullname not in EMBEDDED_SOURCES:
            return None
        is_package = fullname in _EMBEDDED_PACKAGES
        loader = _EmbeddedLoader()
        spec = importlib.util.spec_from_loader(
            fullname, loader, origin=f"<embedded {fullname}>", is_package=is_package
        )
        if is_package and spec is not None:
            spec.submodule_search_locations = []
        return spec


if not any(isinstance(finder, _EmbeddedFinder) for finder in sys.meta_path):
    sys.meta_path.insert(0, _EmbeddedFinder())

_CONFIG_YAML = "# @package _global_\n\nscratch:\n  resolution: 512\n  train_video_batch_size: 2 # increase batch size based on your computing\n  num_train_workers: 15\n  num_frames: 1\n  max_num_objects: 3\n  base_lr: 5.0e-5\n  vision_lr: 3.0e-05\n  phases_per_epoch: 1\n  num_epochs: 300\n\ndataset:\n  # PATHS to Dataset\n  folder: /home/wensheng/gjq_workspace/eyesam/data/Retina_Project  # Root path containing train/ and val/ splits\n  multiplier: 1\n\n# Video transforms\nvos:\n  train_transforms:\n    - _target_: training.dataset.transforms.ComposeAPI\n      transforms:\n        - _target_: training.dataset.transforms.RandomHorizontalFlip\n          consistent_transform: True\n        - _target_: training.dataset.transforms.RandomAffine\n          degrees: 25\n          shear: 20\n          image_interpolation: bilinear\n          consistent_transform: True\n        - _target_: training.dataset.transforms.RandomResizeAPI\n          sizes: ${scratch.resolution}\n          square: true\n          consistent_transform: True\n        - _target_: training.dataset.transforms.ColorJitter\n          consistent_transform: True\n          brightness: 0.1\n          contrast: 0.03\n          saturation: 0.03\n          hue: null\n        - _target_: training.dataset.transforms.RandomGrayscale\n          p: 0.05\n          consistent_transform: True\n        - _target_: training.dataset.transforms.ColorJitter\n          consistent_transform: False\n          brightness: 0.1\n          contrast: 0.05\n          saturation: 0.05\n          hue: null\n        - _target_: training.dataset.transforms.ToTensorAPI\n        - _target_: training.dataset.transforms.NormalizeAPI\n          mean: [0.485, 0.456, 0.406]\n          std: [0.229, 0.224, 0.225]\n  val_transforms:\n    - _target_: training.dataset.transforms.ComposeAPI\n      transforms:\n        - _target_: training.dataset.transforms.RandomResizeAPI\n          sizes: ${scratch.resolution}\n          square: true\n          consistent_transform: True\n        - _target_: training.dataset.transforms.ToTensorAPI\n        - _target_: training.dataset.transforms.NormalizeAPI\n          mean: [0.485, 0.456, 0.406]\n          std: [0.229, 0.224, 0.225]\n\n\ntrainer:\n  _target_: training.trainer.Trainer\n  mode: train\n  max_epochs: ${times:${scratch.num_epochs},${scratch.phases_per_epoch}}\n  accelerator: cuda\n  seed_value: 123\n\n  model:\n    _target_: training.model.sam2.SAM2Train\n    image_encoder:\n      _target_: sam2.modeling.backbones.image_encoder.ImageEncoder\n      scalp: 1\n      trunk:\n        _target_: sam2.modeling.backbones.hieradet.Hiera\n        embed_dim: 96\n        num_heads: 1\n        stages: [1, 2, 7, 2]\n        global_att_blocks: [5, 7, 9]\n        window_pos_embed_bkg_spatial_size: [7, 7]\n      neck:\n        _target_: sam2.modeling.backbones.image_encoder.FpnNeck\n        position_encoding:\n          _target_: sam2.modeling.position_encoding.PositionEmbeddingSine\n          num_pos_feats: 256\n          normalize: true\n          scale: null\n          temperature: 10000\n        d_model: 256\n        backbone_channel_list: [768, 384, 192, 96]\n        fpn_top_down_levels: [2, 3]  # output level 0 and 1 directly use the backbone features\n        fpn_interp_model: nearest\n\n    memory_attention:\n      _target_: sam2.modeling.memory_attention.MemoryAttention\n      d_model: 256\n      pos_enc_at_input: true\n      layer:\n        _target_: sam2.modeling.memory_attention.MemoryAttentionLayer\n        activation: relu\n        dim_feedforward: 2048\n        dropout: 0.1\n        pos_enc_at_attn: false\n        self_attention:\n          _target_: sam2.modeling.sam.transformer.RoPEAttention\n          rope_theta: 10000.0\n          feat_sizes: [32, 32]\n          embedding_dim: 256\n          num_heads: 1\n          downsample_rate: 1\n          dropout: 0.1\n        d_model: 256\n        pos_enc_at_cross_attn_keys: true\n        pos_enc_at_cross_attn_queries: false\n        cross_attention:\n          _target_: sam2.modeling.sam.transformer.RoPEAttention\n          rope_theta: 10000.0\n          feat_sizes: [32, 32]\n          rope_k_repeat: True\n          embedding_dim: 256\n          num_heads: 1\n          downsample_rate: 1\n          dropout: 0.1\n          kv_in_dim: 64\n      num_layers: 4\n\n    memory_encoder:\n        _target_: sam2.modeling.memory_encoder.MemoryEncoder\n        out_dim: 64\n        position_encoding:\n          _target_: sam2.modeling.position_encoding.PositionEmbeddingSine\n          num_pos_feats: 64\n          normalize: true\n          scale: null\n          temperature: 10000\n        mask_downsampler:\n          _target_: sam2.modeling.memory_encoder.MaskDownSampler\n          kernel_size: 3\n          stride: 2\n          padding: 1\n        fuser:\n          _target_: sam2.modeling.memory_encoder.Fuser\n          layer:\n            _target_: sam2.modeling.memory_encoder.CXBlock\n            dim: 256\n            kernel_size: 7\n            padding: 3\n            layer_scale_init_value: 1.0e-6\n            use_dwconv: True  # depth-wise convs\n          num_layers: 2\n\n    num_maskmem: 7\n    image_size: ${scratch.resolution}\n    # apply scaled sigmoid on mask logits for memory encoder, and directly feed input mask as output mask\n    # SAM decoder\n    sigmoid_scale_for_mem_enc: 20.0\n    sigmoid_bias_for_mem_enc: -10.0\n    use_mask_input_as_output_without_sam: true\n    # Memory\n    directly_add_no_mem_embed: true\n    no_obj_embed_spatial: true\n    # use high-resolution feature map in the SAM mask decoder\n    use_high_res_features_in_sam: true\n    # output 3 masks on the first click on initial conditioning frames\n    multimask_output_in_sam: true\n    # SAM heads\n    iou_prediction_use_sigmoid: True\n    # cross-attend to object pointers from other frames (based on SAM output tokens) in the encoder\n    use_obj_ptrs_in_encoder: true\n    add_tpos_enc_to_obj_ptrs: true\n    proj_tpos_enc_in_obj_ptrs: true\n    use_signed_tpos_enc_to_obj_ptrs: true\n    only_obj_ptrs_in_the_past_for_eval: true\n    # object occlusion prediction\n    pred_obj_scores: true\n    pred_obj_scores_mlp: true\n    fixed_no_obj_ptr: true\n    # multimask tracking settings\n    multimask_output_for_tracking: true\n    use_multimask_token_for_obj_ptr: true\n    multimask_min_pt_num: 0\n    multimask_max_pt_num: 1\n    use_mlp_for_obj_ptr_proj: true\n    # Compilation flag\n    # compile_image_encoder: False\n\n    ####### Training specific params #######\n    # box/point input and corrections\n    prob_to_use_pt_input_for_train: 1.0\n    prob_to_use_pt_input_for_eval: 1.0\n    prob_to_use_box_input_for_train: 0.0\n    prob_to_use_box_input_for_eval: 0.0\n    prob_to_sample_from_gt_for_train: 0.1  # with a small prob, sampling correction points from GT mask instead of prediction errors\n    num_frames_to_correct_for_train: 1  # single-frame data, only correct the first frame\n    num_frames_to_correct_for_eval: 1  # only iteratively sample on first frame\n    rand_frames_to_correct_for_train: False  # single-frame data, no random correction frames\n    add_all_frames_to_correct_as_cond: True  # when a frame receives a correction click, it becomes a conditioning frame (even if it's not initially a conditioning frame)\n    # maximum 1 initial conditioning frame\n    num_init_cond_frames_for_train: 1\n    rand_init_cond_frames_for_train: False  # single-frame data, no random conditioning frames\n    num_correction_pt_per_frame: 7\n    use_act_ckpt_iterative_pt_sampling: false\n    \n\n    \n    num_init_cond_frames_for_eval: 1  # only mask on the first frame\n    forward_backbone_per_frame_for_eval: True\n    \n\n  data:\n    train:\n      _target_: training.dataset.sam2_datasets.TorchTrainMixedDataset\n      phases_per_epoch: ${scratch.phases_per_epoch}\n      batch_sizes:\n        - ${scratch.train_video_batch_size}\n      datasets:\n        - _target_: training.dataset.utils.RepeatFactorWrapper\n          dataset:\n            _target_: training.dataset.utils.ConcatDataset\n            datasets:\n            # CT Lesion npz dataset\n            - _target_: training.dataset.vos_dataset.VOSDataset\n              transforms: ${vos.train_transforms}\n              training: true\n              video_dataset:\n                _target_: training.dataset.vos_raw_dataset.NPZRawDataset\n                folder: /home/wensheng/gjq_workspace/eyesam/data/Retina_Project/train_npz # must be absolute path\n              sampler:\n                _target_: training.dataset.vos_sampler.RandomUniformSampler\n                num_frames: ${scratch.num_frames}\n                max_num_objects: ${scratch.max_num_objects}\n              multiplier: 1\n            \n\n      shuffle: True\n      num_workers: ${scratch.num_train_workers}\n      pin_memory: True\n      drop_last: True\n      collate_fn:\n        _target_: training.utils.data_utils.collate_fn\n        _partial_: true\n        dict_key: laser\n    val:\n      _target_: training.dataset.sam2_datasets.TorchTrainMixedDataset\n      phases_per_epoch: 1\n      batch_sizes:\n        - ${scratch.train_video_batch_size}\n      datasets:\n        - _target_: training.dataset.utils.RepeatFactorWrapper\n          dataset:\n            _target_: training.dataset.utils.ConcatDataset\n            datasets:\n            - _target_: training.dataset.vos_dataset.VOSDataset\n              transforms: ${vos.val_transforms}\n              training: false\n              video_dataset:\n                _target_: training.dataset.vos_raw_dataset.NPZRawDataset\n                folder: /home/wensheng/gjq_workspace/eyesam/data/Retina_Project/val_npz\n              sampler:\n                _target_: training.dataset.vos_sampler.RandomUniformSampler\n                num_frames: ${scratch.num_frames}\n                max_num_objects: ${scratch.max_num_objects}\n              multiplier: 1\n      shuffle: False\n      num_workers: ${scratch.num_train_workers}\n      pin_memory: True\n      drop_last: False\n      collate_fn:\n        _target_: training.utils.data_utils.collate_fn\n        _partial_: true\n        dict_key: laser\n\n  optim:\n    amp:\n      enabled: True\n      amp_dtype: bfloat16\n\n    optimizer:\n      _target_: torch.optim.AdamW\n\n    gradient_clip:\n      _target_: training.optimizer.GradientClipper\n      max_norm: 0.1\n      norm_type: 2\n\n    param_group_modifiers:\n      - _target_: training.optimizer.layer_decay_param_modifier\n        _partial_: True\n        layer_decay_value: 0.9\n        apply_to: 'image_encoder.trunk'\n        overrides:\n          - pattern: '*pos_embed*'\n            value: 1.0\n\n    options:\n      lr:\n        - scheduler:\n            _target_: fvcore.common.param_scheduler.CosineParamScheduler\n            start_value: ${scratch.base_lr}\n            end_value: ${divide:${scratch.base_lr},10}\n        - scheduler:\n            _target_: fvcore.common.param_scheduler.CosineParamScheduler\n            start_value: ${scratch.vision_lr}\n            end_value: ${divide:${scratch.vision_lr},10}\n          param_names:\n            - 'image_encoder.*'\n      weight_decay:\n        - scheduler:\n            _target_: fvcore.common.param_scheduler.ConstantParamScheduler\n            value: 0.1\n        - scheduler:\n            _target_: fvcore.common.param_scheduler.ConstantParamScheduler\n            value: 0.0\n          param_names:\n            - '*bias*'\n          module_cls_names: ['torch.nn.LayerNorm']\n\n  loss:\n    laser:\n      _target_: training.loss_fns.MultiStepMultiMasksAndIous\n      weight_dict:\n        loss_mask: 20\n        loss_dice: 1\n        loss_iou: 1\n        loss_class: 1\n      supervise_all_iou: true\n      iou_use_l1_loss: true\n      pred_obj_scores: true\n      focal_gamma_obj_score: 0.0\n      focal_alpha_obj_score: -1.0\n\n  distributed:\n    backend: nccl #  gloo or nccl\n    find_unused_parameters: True\n\n  logging:\n    tensorboard_writer:\n      _target_: training.utils.logger.make_tensorboard_logger\n      log_dir:  ${launcher.experiment_log_dir}/tensorboard\n      flush_secs: 120\n      should_log: True\n    visdom_writer:\n      _target_: training.utils.logger.make_visdom_logger\n      env: sam2_train\n      server: http://localhost\n      port: 8097\n      raise_exceptions: False\n      should_log: True\n    log_dir: ${launcher.experiment_log_dir}/logs\n    log_freq: 10\n    log_visual_frequency: 100\n    visdom_image_mean: [0.485, 0.456, 0.406]\n    visdom_image_std: [0.229, 0.224, 0.225]\n\n  # initialize from a SAM 2 checkpoint\n  checkpoint:\n    save_dir: ${launcher.experiment_log_dir}/checkpoints\n    save_freq: 10 # 0 only last checkpoint is saved.\n    model_weight_initializer:\n      _partial_: True\n      _target_: training.utils.checkpoint_utils.load_state_dict_into_model\n      strict: True\n      ignore_unexpected_keys: null\n      ignore_missing_keys: null\n\n      state_dict:\n        _target_: training.utils.checkpoint_utils.load_checkpoint_and_apply_kernels\n        checkpoint_path: checkpoints/MedSAM2_latest.pt # PATH to SAM 2.1 checkpoint\n        ckpt_state_dict_keys: ['model']\n\nlauncher:\n  num_nodes: 1\n  gpus_per_node: 2\n  experiment_log_dir: exp_log # Path to log directory, defaults to ./sam2_logs/${config_name}\n\n# SLURM args if running on a cluster\nsubmitit:\n  partition: gpu_bwanggroup\n  account: null\n  qos: null\n  cpus_per_task: 10\n  use_cluster: false\n  timeout_hour: 24\n  name: null\n  port_range: [10000, 65000]\n"


def get_best_available_device() -> str:
    if torch.cuda.is_available():
        return "cuda"
    if hasattr(torch.backends, "mps") and torch.backends.mps.is_available():
        return "mps"
    return "cpu"


def _prepare_model_config(apply_postprocessing: bool, overrides: Dict[str, Any] | None = None):
    cfg = OmegaConf.create(yaml.safe_load(_CONFIG_YAML))
    OmegaConf.resolve(cfg)
    model_cfg = cfg["trainer"]["model"]
    model_cfg["_target_"] = "sam2.sam2_video_predictor_npz.SAM2VideoPredictorNPZ"
    if not apply_postprocessing:
        model_cfg["fill_hole_area"] = 0
    if overrides:
        for key, value in overrides.items():
            model_cfg[key] = value
    return model_cfg


def _filter_model_kwargs(model_cfg) -> Dict[str, Any]:
    from sam2.modeling.sam2_base import SAM2Base
    from sam2.sam2_video_predictor_npz import SAM2VideoPredictorNPZ
    base_params = set(inspect.signature(SAM2Base.__init__).parameters)
    predictor_params = set(inspect.signature(SAM2VideoPredictorNPZ.__init__).parameters)
    allowed = base_params.union(predictor_params) - {"self"}
    return {k: v for k, v in model_cfg.items() if k in allowed}


def build_sam2_video_predictor_npz(
    ckpt_path: str | None = None,
    device: str | None = None,
    mode: str = "eval",
    apply_postprocessing: bool = False,
    overrides: Dict[str, Any] | None = None,
):
    device = device or get_best_available_device()
    model_cfg = _prepare_model_config(apply_postprocessing, overrides)
    model_kwargs = _filter_model_kwargs(model_cfg)
    model = instantiate(model_kwargs, _recursive_=True)
    if ckpt_path is not None:
        state = torch.load(ckpt_path, map_location="cpu", weights_only=True)
        state_dict = state.get("model", state)
        model.load_state_dict(state_dict, strict=True)
    model = model.to(device)
    if mode == "eval":
        model.eval()
    return model
